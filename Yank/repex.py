#!/usr/local/bin/env python

# ==============================================================================
# MODULE DOCSTRING
# ==============================================================================

"""Replica-exchange simulation algorithms and specific variants.

This module provides a general facility for running replica-exchange simulations,
as well as derived classes for special cases such as parallel tempering (in which
the states differ only in temperature).

Provided classes include:

- ReplicaExchange
    Base class for general replica-exchange simulations.
- ParallelTempering
    Convenience subclass of ReplicaExchange for parallel tempering simulations
    (one System object, many temperatures).

COPYRIGHT

Written by John D. Chodera <jchodera@gmail.com> while at the University of
California Berkeley.

LICENSE

This code is licensed under the latest available version of the MIT License.

"""

# ==============================================================================
# GLOBAL IMPORTS
# ==============================================================================

from simtk import openmm
from simtk import unit

import os
import math
import copy
import time
import yaml
import inspect
import datetime
import logging
import collections

import numpy as np
import mdtraj as md
import netCDF4 as netcdf

import openmmtools as mmtools
from openmmtools.states import ThermodynamicState

from . import utils, mpi, version

logger = logging.getLogger(__name__)


# ==============================================================================
# REPLICA EXCHANGE REPORTER
# ==============================================================================

class Reporter(object):
    """Handle storage write/read operations and different format conventions.

    You can use this object to programmatically inspect the data generated by
    ReplicaExchange.

    Parameters
    ----------
    base_storage : str
        The path to the files base name, this should not include a file suffix
        The multiple storage files will be saved as two files named
            "base_storage + _checkpointing" and "base_storage + _analysis"
        In the future this will be able to take Storage classes as well.
    open_mode : str or None
        The mode of the file between 'r', 'w', and 'a' (or equivalently 'r+').
        If None, the storage file won't be open on construction, and a call to
        Reporter.open() will be needed before attempting read/write operations.
    checkpoint_interval : int >= 1, Default: 10
        The frequency at which checkpointing information is written relative to analysis information. This is a multiple
        of the iteration at which energies is written, hence why it must be greater than or equal to 1.
        Checkpoint information cannot be written on iterations which where iteration % checkpoint_interval != 0.
        Attempting to read checkpointing information results in a masked array where only entries which were written
            are unmasked

    """
    def __init__(self, base_storage, open_mode=None, checkpoint_interval=10):
        if type(checkpoint_interval) != int:
            raise ValueError("checkpoint_interval must be an integer!")
        self._storage_file_base = base_storage
        self._storage_file_checkpoint = base_storage + "_checkpointing.nc"
        self._storage_file_analysis = base_storage + "_analysis.nc"
        self._storage_checkpoint = None
        self._storage_analysis = None
        self._checkpoint_interval = checkpoint_interval
        if open_mode is not None:
            self.open(open_mode)

    @property
    def _storage(self):
        """Return an iterable of the storage objects, avoids writing things like "for Z in [X,Y]" calls everywhere"""
        return self._storage_checkpoint, self._storage_analysis

    @property
    def _storage_dict(self):
        """Return an iterable dictionary of the self._storage_X objects"""
        return {'checkpoint': self._storage_checkpoint, 'analysis': self._storage_analysis}

    def is_open(self):
        """Return True if the Reporter is ready to read/write."""
        if self._storage[0] is None or self._storage[1] is None:
            return False
        return np.all([self._storage[0].isopen(), self._storage[1].isopen()])

    def open(self, mode='r'):
        """Open the storage file for reading/writing.

        This is not necessary if you have indicated in the constructor to open.

        Parameters
        ----------
        mode : str
            The mode of the file between 'r', 'w', and 'a' (or equivalently 'r+').

        """
        # Ensure we don't have already another file
        # open (possibly in a different mode).
        if self._storage[0] is None or self._storage[1] is None:
            self.close()

        # Create directory if we want to write.
        if mode != 'r':
            storage_dir = os.path.dirname(self._storage_file_base)
            if not os.path.exists(storage_dir):
                os.makedirs(storage_dir)

        # Open NetCDF 4 file for writing.
        ncfile_checkpoint = netcdf.Dataset(self._storage_file_checkpoint, mode, version='NETCDF4')
        ncfile_analysis = netcdf.Dataset(self._storage_file_analysis, mode, version='NETCDF4')
        ncfiles = {'checkpoint': ncfile_checkpoint,
                   'analysis': ncfile_analysis
                   }

        # Create header if needed.
        for nc_name, ncfile in utils.dictiter(ncfiles):
            if 'scalar' not in ncfile.dimensions:
                # Create common dimensions.
                ncfile.createDimension('scalar', 1)  # Scalar dimension.
                ncfile.createDimension('iteration', 0)  # Unlimited number of iterations.
                ncfile.createDimension('spatial', 3)  # Number of spatial dimensions.

                # Set global attributes.
                ncfile.application = 'YANK'
                ncfile.program = 'yank.py'
                ncfile.programVersion = version.short_version
                ncfile.Conventions = 'ReplicaExchange'
                ncfile.ConventionVersion = '0.2'
                ncfile.DataUsedFor = nc_name
                ncfile.checkpoint_interval = self._checkpoint_interval
            setattr(self, '_storage_' + nc_name, ncfile)
        on_file_interval = self._storage_checkpoint.checkpoint_interval
        if on_file_interval != self._checkpoint_interval:
            logger.debug("checkpoint_interval != on-file checkpoint interval! "
                         "Using on file checkpoint interval of {}.".format(on_file_interval))
            self._checkpoint_interval = on_file_interval

    def close(self):
        """Close the storage file."""
        for storage_name, storage in utils.dictiter(self._storage_dict):
            if storage is not None:
                storage.sync()
                storage.close()
                setattr(self, '_storage' + storage_name, None)

    def sync(self):
        """Force any buffer to be flushed to the file."""
        for storage in self._storage:
            if storage is not None:
                storage.sync()

    def __del__(self):
        """Synchronize and close the storage."""
        if self._storage[0] is not None or self._storage[1] is not None:
            self.close()

    @mmtools.utils.with_timer('Reading thermodynamic states from storage')
    def read_thermodynamic_states(self):
        """Retrieve the stored thermodynamic states from the checkpoint file.

        Returns
        -------
        thermodynamic_states : list of ThermodynamicStates
            The previously stored thermodynamic states. During the simulation
            these are swapped among replicas.
        unsampled_states : list of ThermodynamicState
            The previously stored unsampled thermodynamic states.

        See Also
        --------
        read_replica_thermodynamic_states

        """
        # We have to parse the thermodynamic states first because the
        # unsampled states may refer to them for the serialized system.
        states = collections.OrderedDict([('thermodynamic_states', list()),
                                          ('unsampled_states', list())])

        # Read state information.
        for state_type, state_list in states.items():
            # There may not be unsampled states.
            if state_type not in self._storage_checkpoint.groups:
                assert state_type == 'unsampled_states'
                continue

            # We keep looking for states until we can't find them anymore.
            n_states = len(self._storage_checkpoint.groups[state_type].variables)
            for state_id in range(n_states):
                serialized_state = self.read_dict('{}/state{}'.format(state_type, state_id), storage='checkpoint')

                # Find the thermodynamic state representation.
                serialized_thermodynamic_state = serialized_state
                while 'thermodynamic_state' in serialized_thermodynamic_state:
                    # The while loop is necessary for nested CompoundThermodynamicStates.
                    serialized_thermodynamic_state = serialized_state['thermodynamic_state']

                # Check if the standard state is in a previous state.
                try:
                    standard_system_name = serialized_thermodynamic_state.pop('_Reporter__compatible_state')
                except KeyError:
                    # We have stored the full standard system serialization.
                    pass
                else:
                    # The system serialization can be retrieved from another state.
                    reference_state_type, reference_system_id = standard_system_name.split('/')
                    compatible_thermodynamic_state = states[reference_state_type][int(reference_system_id)]
                    serialized_system = openmm.XmlSerializer.serialize(compatible_thermodynamic_state.system)
                    serialized_thermodynamic_state['standard_system'] = serialized_system

                # Create ThermodynamicState object.
                states[state_type].append(mmtools.utils.deserialize(serialized_state))
                state_id += 1

        return [states['thermodynamic_states'], states['unsampled_states']]

    @mmtools.utils.with_timer('Storing thermodynamic states')
    def write_thermodynamic_states(self, thermodynamic_states, unsampled_states):
        """Store all the ThermodynamicStates to the checkpoint file.

        Parameters
        ----------
        thermodynamic_states : list of ThermodynamicState
            The thermodynamic states to store.
        unsampled_states : list of ThermodynamicState
            The unsampled thermodynamic states to store.

        See Also
        --------
        write_replica_thermodynamic_states

        """
        # Store all thermodynamic states as serialized dictionaries.
        compatible_states_hashes = dict()
        for state_type, states in [('thermodynamic_states', thermodynamic_states),
                                   ('unsampled_states', unsampled_states)]:
            for state_id, thermodynamic_state in enumerate(states):
                serialized_state = mmtools.utils.serialize(thermodynamic_state)

                # Find the serialized standard system.
                serialized_thermodynamic_state = serialized_state
                while 'thermodynamic_state' in serialized_thermodynamic_state:
                    # The while loop is necessary for nested CompoundThermodynamicStates.
                    serialized_thermodynamic_state = serialized_state['thermodynamic_state']
                serialized_standard_system = serialized_thermodynamic_state['standard_system']

                # We store the full standard system serialization only if we haven't
                # store it yet, otherwise we just write a reference to a state containing
                # the full system. We normally expect all the ThermodynamicStates to be
                # compatible, which means we'll store only a single system in most cases.
                standard_system_hash = serialized_standard_system.__hash__()
                try:
                    reference_state_name, len_serialization = compatible_states_hashes[standard_system_hash]
                except KeyError:
                    reference_state_name = '{}/{}'.format(state_type, state_id)
                    len_serialization = len(serialized_standard_system)
                    compatible_states_hashes[standard_system_hash] = reference_state_name, len_serialization

                    logger.debug("Serialized state {} is  {}B | {:.3f}KB | {:.3f}MB".format(
                        reference_state_name, len_serialization, len_serialization/1024.0,
                        len_serialization/1024.0/1024.0))
                else:
                    serialized_thermodynamic_state.pop('standard_system')
                    serialized_thermodynamic_state['_Reporter__compatible_state'] = reference_state_name

                # Write state as dictionary.
                self.write_dict('{}/state{}'.format(state_type, state_id), serialized_state, storage='checkpoint')

    def read_sampler_states(self, iteration):
        """Retrieve the stored sampler states on the checkpoint file

        If the iteration is not on the checkpoint interval, None is returned

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        Returns
        -------
        sampler_states : list of SamplerStates or None
            The previously stored sampler states for each replica.
            If the iteration is not on the checkpoint_interval, None is returned

        """

        checkpoint_iteration = self._calculate_checkpoint_iteration(iteration)
        if checkpoint_iteration:
            n_states = self._storage_checkpoint.dimensions['replica'].size

            sampler_states = list()
            for replica_index in range(n_states):
                # Restore positions.
                x = self._storage_checkpoint.variables['positions'][checkpoint_iteration, replica_index, :, :].astype(np.float64)
                positions = unit.Quantity(x, unit.nanometers)

                # Restore box vectors.
                x = self._storage_checkpoint.variables['box_vectors'][checkpoint_iteration, replica_index, :, :].astype(np.float64)
                box_vectors = unit.Quantity(x, unit.nanometers)

                # Create SamplerState.
                sampler_states.append(mmtools.states.SamplerState(positions=positions, box_vectors=box_vectors))

            return sampler_states
        else:
            return None

    @mmtools.utils.with_timer('Storing sampler states')
    def write_sampler_states(self, sampler_states, iteration):
        """Store all sampler states for a given iteration on the checkpoint file

        If the iteration is not on the checkpoint interval, no data is written

        Parameters
        ----------
        sampler_states : list of SamplerStates
            The sampler states to store for each replica.
        iteration : int
            The iteration at which to store the data.

        """
        # Check if the schema must be initialized, do this regardless of the checkpoint_interval for consistency
        if 'positions' not in self._storage_checkpoint.variables:
            n_atoms = sampler_states[0].n_particles
            n_states = len(sampler_states)

            # Create dimensions. Replica dimension could have been created before.
            self._storage_checkpoint.createDimension('atom', n_atoms)
            if 'replica' not in self._storage_checkpoint.dimensions:
                self._storage_checkpoint.createDimension('replica', n_states)

            # Create variables.
            ncvar_positions = self._storage_checkpoint.createVariable('positions', 'f4',
                                                                      ('iteration', 'replica', 'atom', 'spatial'),
                                                                      zlib=True, chunksizes=(1, n_states, n_atoms, 3))
            ncvar_box_vectors = self._storage_checkpoint.createVariable('box_vectors', 'f4',
                                                                        ('iteration', 'replica', 'spatial', 'spatial'),
                                                                        zlib=False, chunksizes=(1, n_states, 3, 3))
            ncvar_volumes = self._storage_checkpoint.createVariable('volumes', 'f8', ('iteration', 'replica'),
                                                                    zlib=False, chunksizes=(1, n_states))

            # Define units for variables.
            setattr(ncvar_positions, 'units', 'nm')
            setattr(ncvar_box_vectors, 'units', 'nm')
            setattr(ncvar_volumes, 'units', 'nm**3')

            # Define long (human-readable) names for variables.
            setattr(ncvar_positions, "long_name", ("positions[iteration][replica][atom][spatial] is position of "
                                                   "coordinate 'spatial' of atom 'atom' from replica 'replica' for "
                                                   "iteration 'iteration'."))

            setattr(ncvar_box_vectors, "long_name", ("box_vectors[iteration][replica][i][j] is dimension j of box "
                                                     "vector i for replica 'replica' from iteration 'iteration-1'."))
            setattr(ncvar_volumes, "long_name", ("volume[iteration][replica] is the box volume for replica 'replica' "
                                                 "from iteration 'iteration-1'."))
        checkpoint_iteration = self._calculate_checkpoint_iteration(iteration)
        if checkpoint_iteration:
            # Store sampler states.
            for replica_index, sampler_state in enumerate(sampler_states):
                # Store positions
                x = sampler_state.positions / unit.nanometers
                self._storage_checkpoint.variables['positions'][checkpoint_iteration, replica_index, :, :] = x[:, :]

                # Store box vectors and volume.
                for i in range(3):
                    vector_i = sampler_state.box_vectors[i] / unit.nanometers
                    self._storage_checkpoint.variables['box_vectors'][checkpoint_iteration, replica_index, i, :] = \
                        vector_i
                self._storage_checkpoint.variables['volumes'][checkpoint_iteration, replica_index] = \
                    sampler_state.volume / unit.nanometers**3
        else:
            logger.debug("Iteration {} not on the Checkpoint Interval of {}. "
                         "Sampler State not written.".format(iteration, self._checkpoint_interval))

    def read_replica_thermodynamic_states(self, iteration=slice(None)):
        """Retrieve the indices of the ThermodynamicStates for each replica on the analysis file

        Parameters
        ----------
        iteration : int or slice
            The iteration(s) at which to read the data. The slice(None) allows fetching all iterations at once.

        Returns
        -------
        state_indices : list of int
            At the given iteration, replica i propagated the system in
            SamplerState sampler_states[i] and ThermodynamicState
            thermodynamic_states[states_indices[i]].

        """
        return self._storage_analysis.variables['states'][iteration].astype(np.int64)

    def write_replica_thermodynamic_states(self, state_indices, iteration):
        """Store the indices of the ThermodynamicStates for each replica on the analysis file

        Parameters
        ----------
        state_indices : list of int
            At the given iteration, replica i propagated the system in
            SamplerState sampler_states[i] and ThermodynamicState
            thermodynamic_states[replica_thermodynamic_states[i]].
        iteration : int
            The iteration at which to store the data.

        """
        # Initialize schema if needed.
        if 'states' not in self._storage_analysis.variables:
            n_states = len(state_indices)

            # Create dimension if they don't exist.
            if 'replica' not in self._storage_analysis.dimensions:
                self._storage_analysis.createDimension('replica', n_states)

            # Create variables and attach units and description.
            ncvar_states = self._storage_analysis.createVariable('states', 'i4', ('iteration', 'replica'),
                                                                 zlib=False, chunksizes=(1, n_states))
            setattr(ncvar_states, 'units', 'none')
            setattr(ncvar_states, "long_name", ("states[iteration][replica] is the thermodynamic state index "
                                                "(0..nstates-1) of replica 'replica' of iteration 'iteration'."))

        # Store thermodynamic states indices.
        self._storage_analysis.variables['states'][iteration, :] = state_indices[:]

    def read_mcmc_moves(self):
        """Return the MCMCMoves of the ReplicaExchange simulation on the checkpoint

        Returns
        -------
        mcmc_moves : list of MCMCMove
            The MCMCMoves used to propagate the simulation.

        """
        n_moves = len(self._storage_checkpoint.groups['mcmc_moves'].variables)

        # Retrieve all moves in order.
        mcmc_moves = list()
        for move_id in range(n_moves):
            serialized_move = self.read_dict('mcmc_moves/move{}'.format(move_id), storage='checkpoint')
            mcmc_moves.append(mmtools.utils.deserialize(serialized_move))
        return mcmc_moves

    def write_mcmc_moves(self, mcmc_moves):
        """Store the MCMCMoves of the ReplicaExchange simulation on the checkpoint

        Parameters
        ----------
        mcmc_moves : list of MCMCMove
            The MCMCMoves used to propagate the simulation.

        """
        for move_id, move in enumerate(mcmc_moves):
            serialized_move = mmtools.utils.serialize(move)
            self.write_dict('mcmc_moves/move{}'.format(move_id), serialized_move, storage='checkpoint')

    def read_energies(self, iteration=slice(None)):
        """Retrieve the energy matrix at the given iteration on the analysis file

        Parameters
        ----------
        iteration : int or slice
            The iteration(s) at which to read the data. The slice(None) allows fetching all iterations at once.

        Returns
        -------
        energy_thermodynamic_states : n_replicas x n_replicas numpy.ndarray
            energy_thermodynamic_states[iteration, i, j] is the reduced potential computed at
            SamplerState sampler_states[iteration, i] and ThermodynamicState thermodynamic_states[iteration, j].
        energy_unsampled_states : n_replicas x n_unsampled_states numpy.ndarray
            energy_unsampled_states[iteration, i, j] is the reduced potential computed at SamplerState
            sampler_states[iteration, i] and ThermodynamicState unsampled_thermodynamic_states[iteration, j].

        """
        energy_thermodynamic_states = self._storage_analysis.variables['energies'][iteration, :, :]
        try:
            energy_unsampled_states = self._storage_analysis.variables['unsampled_energies'][iteration, :, :]
        except KeyError:
            # There are no unsampled thermodynamic states.
            unsampled_shape = energy_thermodynamic_states.shape[:-1] + (0,)
            energy_unsampled_states = np.zeros(unsampled_shape)
        return energy_thermodynamic_states, energy_unsampled_states

    def write_energies(self, energy_thermodynamic_states, energy_unsampled_states, iteration):
        """Store the energy matrix at the given iteration on the analysis file

        Parameters
        ----------
        energy_thermodynamic_states : n_replicas x n_replicas numpy.ndarray
            energy_thermodynamic_states[i][j] is the reduced potential computed at
            SamplerState sampler_states[i] and ThermodynamicState thermodynamic_states[j].
        energy_unsampled_states : n_replicas x n_unsampled_states numpy.ndarray
            energy_unsampled_states[i][j] is the reduced potential computed at SamplerState
            sampler_states[i] and ThermodynamicState unsampled_thermodynamic_states[j].
        iteration : int
            The iteration at which to store the data.

        """
        # Initialize schema if needed.
        if 'energies' not in self._storage_analysis.variables:
            n_replicas = len(energy_thermodynamic_states)

            # Create replica dimension if it wasn't created by other functions.
            if 'replica' not in self._storage_analysis.dimensions:
                self._storage_analysis.createDimension('replica', n_replicas)

            # Create variable for thermodynamic state energies with units and descriptions.
            ncvar_energies = self._storage_analysis.createVariable('energies',
                                                                   'f8',
                                                                   ('iteration', 'replica', 'replica'),
                                                                   zlib=False,
                                                                   chunksizes=(1, n_replicas, n_replicas))
            ncvar_energies.units = 'kT'
            ncvar_energies.long_name = ("energies[iteration][replica][state] is the reduced (unitless) "
                                        "energy of replica 'replica' from iteration 'iteration' evaluated "
                                        "at the thermodynamic state 'state'.")

            # Check if we have unsampled states.
            if energy_unsampled_states.shape[1] > 0:
                if 'unsampled_energies' not in self._storage_analysis.variables:
                    n_unsampled_states = len(energy_unsampled_states[0])

                    # Create replica dimension if it wasn't created by other functions.
                    if 'unsampled' not in self._storage_analysis.dimensions:
                        self._storage_analysis.createDimension('unsampled', n_unsampled_states)

                    # Create variable for thermodynamic state energies with units and descriptions.
                    ncvar_unsampled = self._storage_analysis.createVariable('unsampled_energies',
                                                                            'f8',
                                                                            ('iteration', 'replica', 'unsampled'),
                                                                            zlib=False,
                                                                            chunksizes=(1,
                                                                                        n_replicas,
                                                                                        n_unsampled_states)
                                                                            )
                    ncvar_unsampled.units = 'kT'
                    ncvar_unsampled.long_name = ("unsampled_energies[iteration][replica][state] is the reduced "
                                                 "(unitless) energy of replica 'replica' from iteration 'iteration' "
                                                 "evaluated at unsampled thermodynamic state 'state'.")

        # Store states energy.
        self._storage_analysis.variables['energies'][iteration, :, :] = energy_thermodynamic_states[:, :]
        if energy_unsampled_states.shape[1] > 0:
            self._storage_analysis.variables['unsampled_energies'][iteration, :, :] = energy_unsampled_states[:, :]

    def read_mixing_statistics(self, iteration=slice(None)):
        """Retrieve the mixing statistics for the given iteration on the analysis file

        Parameters
        ----------
        iteration : int or slice
            The iteration(s) at which to read the data.

        Returns
        -------
        n_accepted_matrix : kxk numpy.ndarray
            n_accepted_matrix[i][j] is the number of accepted moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).
        n_proposed_matrix : kxk numpy.ndarray
            n_proposed_matrix[i][j] is the number of proposed moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).

        """
        n_accepted_matrix = self._storage_analysis.variables['accepted'][iteration, :, :].astype(np.int64)
        n_proposed_matrix = self._storage_analysis.variables['proposed'][iteration, :, :].astype(np.int64)
        return n_accepted_matrix, n_proposed_matrix

    def write_mixing_statistics(self, n_accepted_matrix, n_proposed_matrix, iteration):
        """Store the mixing statistics for the given iteration on the analysis file

        Parameters
        ----------
        n_accepted_matrix : kxk numpy.ndarray
            n_accepted_matrix[i][j] is the number of accepted moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).
        n_proposed_matrix : kxk numpy.ndarray
            n_proposed_matrix[i][j] is the number of proposed moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).
        iteration : int
            The iteration at which to store the data.

        """
        # Create schema if necessary.
        if 'accepted' not in self._storage_analysis.variables:
            n_states = len(n_accepted_matrix)

            # Create replica dimension if it wasn't already created.
            if 'replica' not in self._storage_analysis.dimensions:
                self._storage_analysis.createDimension('replica', n_states)

            # Create variables with units and descriptions.
            ncvar_accepted = self._storage_analysis.createVariable('accepted',
                                                                   'i4',
                                                                   ('iteration', 'replica', 'replica'),
                                                                   zlib=False,
                                                                   chunksizes=(1, n_states, n_states)
                                                                   )
            ncvar_proposed = self._storage_analysis.createVariable('proposed',
                                                                   'i4',
                                                                   ('iteration', 'replica', 'replica'),
                                                                   zlib=False,
                                                                   chunksizes=(1, n_states, n_states)
                                                                   )
            setattr(ncvar_accepted, 'units', 'none')
            setattr(ncvar_proposed, 'units', 'none')
            setattr(ncvar_accepted, 'long_name', ("accepted[iteration][i][j] is the number of proposed transitions "
                                                  "between states i and j from iteration 'iteration-1'."))
            setattr(ncvar_proposed, 'long_name', ("proposed[iteration][i][j] is the number of proposed transitions "
                                                  "between states i and j from iteration 'iteration-1'."))

        # Store statistics.
        self._storage_analysis.variables['accepted'][iteration, :, :] = n_accepted_matrix[:, :]
        self._storage_analysis.variables['proposed'][iteration, :, :] = n_proposed_matrix[:, :]

    def read_timestamp(self, iteration=slice(None)):
        """Return the timestamp for the given iteration.

        Read from the analysis file, although there is a paired timestamp on the checkpoint file as well

        Parameters
        ----------
        iteration : int or slice
            The iteration(s) at which to read the data.

        Returns
        -------
        timestamp : str
            The timestamp at which the iteration was stored.

        """
        return self._storage_analysis.variables['timestamp'][iteration]

    def write_timestamp(self, iteration):
        """Store a timestamp for the given iteration on both analysis and checkpoint file.

        If the iteration is not on the checkpoint_interval, no timestamp is written

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        """
        # Create variable if needed.
        for storage in self._storage:
            if 'timestamp' not in storage.variables:
                storage.createVariable('timestamp', str, ('iteration',), zlib=False, chunksizes=(1,))
        timestamp = time.ctime()
        self._storage_analysis.variables['timestamp'][iteration] = timestamp
        checkpoint_interval = self._calculate_checkpoint_iteration(iteration)
        if checkpoint_interval:
            self._storage_checkpoint.variables['timestamp'][iteration] = timestamp

    def read_dict(self, name, storage='analysis'):
        """Restore a dictionary from the storage file.

        Parameters
        ----------
        name : str
            The identifier of the dictionary used to stored the data.
        storage : 'analysis' or 'checkpoint', optional, Default: 'analysis'
            Stores a dictionary on the given storage file.
            'analysis': Frequently written/accessed data, usually smaller in size
                e.g. energies, state indices, etc.
            'checkpoint': Infrequent written/accessed data, usually larger and needed to restore from a checkpoint
                e.g. Explicit solvent coordinates, serialized state string, simulation options.

        Returns
        -------
        data : dict
            The restored data as a dict.

        """
        if storage not in ['analysis', 'checkpoint']:
            raise ValueError("storage must be either 'analysis' or 'checkpoint'!")
        # Get NC variable.
        nc_variable = self._resolve_variable_path(name, storage)
        data_str = str(nc_variable[0])
        data = yaml.load(data_str, Loader=_DictYamlLoader)

        # Restore the title in the metadata.
        if name == 'metadata':
            data['title'] = self._storage_dict[storage].title
        return data

    def write_dict(self, name, data, storage='analysis'):
        """Store the contents of a dict.

        Parameters
        ----------
        name : str
            The identifier of the dictionary in the storage file.
        data : dict
            The dict to store.
        storage : 'analysis' or 'checkpoint', optional, Default: 'analysis'
            Stores a dictionary on the given storage file. Valid options are 'analysis' and 'checkpoint'.
            'analysis': Frequently written/accessed data, usually smaller in size
                e.g. energies, state indices, etc.
            'checkpoint': Infrequent written/accessed data, usually larger and needed to restore from a checkpoint
                e.g. Explicit solvent coordinates, serialized state string, simulation options.

        """
        # General NetCDF conventions assume the title of the dataset to be
        # specified as a global attribute, but the user can specify their
        # own titles only in metadata.
        if storage not in ['analysis', 'checkpoint']:
            raise ValueError("storage must be either 'analysis' or 'checkpoint'!")
        if name == 'metadata':
            data = copy.deepcopy(data)
            self._storage_dict[storage].title = data.pop('title')

        # Check if we are updating the dictionary or creating it.
        try:
            nc_variable = self._resolve_variable_path(name, storage)
        except KeyError:
            nc_variable = self._storage_dict[storage].createVariable(name, str, 'scalar')

        # Activate flow style to save space.
        data_str = yaml.dump(data, Dumper=_DictYamlDumper)#, default_flow_style=True)
        packed_data = np.empty(1, 'O')
        packed_data[0] = data_str
        nc_variable[:] = packed_data

    def get_previous_checkpoint(self, iteration):
        """
        Find the most recently written checkpoint given the iteration searching backwards.

        This is the primary function for determining which iteration to resume from

        Parameters
        ----------
        iteration : int
            Iteration to search from

        Returns
        -------
        checkpoint : int
            The checkpoint closest to the iteration searching reverse
        """
        for i in range(iteration, -1, -1):  # -1 for stop ensures the 0th index is searched
            if self._calculate_checkpoint_iteration(i):
                return i
        raise RuntimeError("Could not find a checkpoint! This should not happen as the 0th iteration should always "
                           "be written! Please check your input.")

    @staticmethod
    def storage_extensions():
        """Returns the list of extensions on the base file name used by this class for analysis and checkpointing

        Primary function is to serve as "does file exist" extensions on the base string
        """
        return "_analysis.nc", "_checkpointing.nc"

    # -------------------------------------------------------------------------
    # Internal-usage.
    # -------------------------------------------------------------------------

    def _resolve_variable_path(self, path, storage):
        """Return the NC variable at the end of the path.

        This can be used to retrieve variables inside one or more groups.

        """
        path_split = path.split('/')
        nc_group = self._storage_dict[storage]
        for group_name in path_split[:-1]:
            nc_group = nc_group.groups[group_name]
        return nc_group.variables[path_split[-1]]

    def _calculate_checkpoint_iteration(self, iteration):
        """Compute the iteration on disk of the checkpoint file matching the iteration linked on the analysis iteration.

         Although this is a simple function, it provides a common function for calculation

         Returns either the integer index, or None if there is no matched index
         """
        checkpoint_index = float(iteration) / self._checkpoint_interval
        if checkpoint_index.is_integer():
            output = int(checkpoint_index)
        else:
            output = None
        return output

    def _calculate_analysis_iteration(self, iteration):
        """Compute the iteration on disk of the analysis file given the checkpoint iteration

        Effectively the inverse of _calculate_checkpoint_iteration
        """
        return iteration * self._checkpoint_interval


# ==============================================================================
# REPLICA-EXCHANGE SIMULATION
# ==============================================================================

class ReplicaExchange(object):
    """Replica-exchange simulation facility.

    This base class provides a general replica-exchange simulation facility,
    allowing any set of thermodynamic states to be specified, along with a
    set of initial positions to be assigned to the replicas in a round-robin
    fashion.

    No distinction is made between one-dimensional and multidimensional replica
    layout. By default, the replica mixing scheme attempts to mix *all* replicas
    to minimize slow diffusion normally found in multidimensional replica exchange
    simulations (Modification of the 'replica_mixing_scheme' setting will allow
    the traditional 'neighbor swaps only' scheme to be used.)

    Stored configurations, energies, swaps, and restart information are all written
    to a single output file using the platform portable, robust, and efficient
    NetCDF4 library.

    Parameters
    ----------
    mcmc_moves : MCMCMove or list of MCMCMove, optional
        The MCMCMove used to propagate the states. If a list of MCMCMoves,
        they will be assigned to the correspondent thermodynamic state on
        creation. If None is provided, Langevin dynamics with 2fm timestep,
        5.0/ps collision rate, and 500 steps per iteration will be used.
    number_of_iterations : int, optional
        The number of iterations to perform (default is 1).
    replica_mixing_scheme : 'swap-all', 'swap-neighbors' or 'none'
        The scheme used to swap thermodynamic states between replicas
        (default is 'swap-all').

    Attributes
    ----------
    mcmc_moves
    number_of_iterations
    replica_mixing_scheme

    Examples
    --------
    Parallel tempering simulation of alanine dipeptide in implicit solvent (replica
    exchange among temperatures). This is just an illustrative example; use ParallelTempering
    class for actual production parallel tempering simulations.

    Create the system.

    >>> import math
    >>> from simtk import unit
    >>> from openmmtools import testsystems, states, mcmc
    >>> testsystem = testsystems.AlanineDipeptideImplicit()

    Create thermodynamic states for parallel tempering with exponentially-spaced schedule.

    >>> n_replicas = 3  # Number of temperature replicas.
    >>> T_min = 298.0 * unit.kelvin  # Minimum temperature.
    >>> T_max = 600.0 * unit.kelvin  # Maximum temperature.
    >>> temperatures = [T_min + (T_max - T_min) * (math.exp(float(i) / float(nreplicas-1)) - 1.0) / (math.e - 1.0)
    ...                 for i in range(n_replicas)]
    >>> thermodynamic_states = [states.ThermodynamicState(system=testsystem.system, temperature=T)
    ...                         for T in temperatures]

    Initialize simulation object with options. Run with a GHMC integrator.

    >>> move = mcmc.GHMCMove(timestep=2.0*unit.femtoseconds, n_steps=50)
    >>> simulation = ReplicaExchange(mcmc_moves=move, number_of_iterations=2, checkpoint_interval=1)

    Create simulation with its storage file (in a temporary directory) and run.

    >>> storage_base_path = tempfile.NamedTemporaryFile(delete=False).name
    >>> simulation.create(thermodynamic_states=thermodynamic_states,
    >>>                   sampler_states=states.SamplerState(testsystem.positions),
    >>>                   storage_base=storage_base_path)
    >>> simulation.run()  # This runs for a maximum of 2 iterations.
    >>> simulation.iteration
    2
    >>> simulation.run(n_iterations=1)
    >>> simulation.iteration
    2

    To resume a simulation from an existing storage file and extend it beyond
    the original number of iterations.

    >>> del simulation
    >>> simulation = ReplicaExchange.from_storage(storage_path)
    >>> simulation.extend(n_iterations=1)
    >>> simulation.iteration
    3

    You can extract several information from the NetCDF file using the Reporter
    class while the simulation is running. This reads the SamplerStates of every
    run iteration.

    >>> reporter = Reporter(storage=storage_path, open_mode='r', checkpoint_interval=1)
    >>> sampler_states = reporter.read_sampler_states(iteration=range(1, 4))
    >>> len(sampler_states)
    3
    >>> sampler_states[-1].positions.shape  # Alanine dipeptide has 22 atoms.
    (22, 3)

    Clean up.

    >>> os.remove(storage_path)

    """

    # -------------------------------------------------------------------------
    # Constructors.
    # -------------------------------------------------------------------------

    def __init__(self, mcmc_moves=None, number_of_iterations=1, replica_mixing_scheme='swap-all'):

        # Check argument values.
        if replica_mixing_scheme not in self._SUPPORTED_MIXING_SCHEMES:
            raise ValueError("Unknown replica mixing scheme '{}'. Supported values are {}.".format(
                replica_mixing_scheme, self._SUPPORTED_MIXING_SCHEMES))

        # Handling default propagator.
        if mcmc_moves is None:
            # This will be converted to a list in create().
            self._mcmc_moves = mmtools.mcmc.LangevinDynamicsMove(timestep=2.0*unit.femtosecond,
                                                                 collision_rate=5.0/unit.picosecond,
                                                                 n_steps=500, reassign_velocities=True,
                                                                 n_restart_attempts=6)
        else:
            self._mcmc_moves = copy.deepcopy(mcmc_moves)

        # Store constructor parameters. Everything is marked for internal
        # usage because any change to these attribute implies a change
        # in the storage file as well.
        self._number_of_iterations = number_of_iterations
        self._replica_mixing_scheme = replica_mixing_scheme

        # These will be set on initialization. See function
        # create() for explanation of single variables.
        self._thermodynamic_states = None
        self._unsampled_states = None
        self._sampler_states = None
        self._replica_thermodynamic_states = None
        self._iteration = None
        self._energy_thermodynamic_states = None
        self._energy_unsampled_states = None
        self._n_accepted_matrix = None
        self._n_proposed_matrix = None
        self._reporter = None
        self._metadata = None
        # Handle checkpointing
        self._checkpoint_interval = None

    @classmethod
    def from_storage(cls, storage_base):
        """Constructor from an existing storage file.

        Parameters
        ----------
        storage_base : str
            The path to the base storage files. In the future this will be able
            to take a Reporter class as well.

        Returns
        -------
        repex : ReplicaExchange
            A new instance of ReplicaExchange in the same state of the
            last stored iteration.

        """
        # Check if netcdf file exists.
        for extension in Reporter.storage_extensions():
            storage_path = storage_base + extension
            if not cls._does_file_exist(storage_path):
                raise RuntimeError('Storage file {} does not exists; cannot resume.'.format(storage_path))

        # Open a reporter to read the data.
        reporter = Reporter(storage_base, open_mode='r')

        # Retrieve options and create new simulation.
        options = reporter.read_dict('options', storage='checkpoint')
        options['mcmc_moves'] = reporter.read_mcmc_moves()
        repex = cls(**options)

        # Display papers to be cited.
        repex._display_citations()

        # Count timestamps to retrieve the current number of iterations.
        # Timestamp is the last thing reported in _report_iteration, so
        # we are sure that the full iteration information has been stored
        # and the simulation has not been interrupted during the report.
        iteration = len(reporter.read_timestamp(iteration=slice(None))) - 1  # 0-based

        # Retrieve other attributes.
        logger.debug("Reading storage files with base {}...".format(storage_base))
        checkpoint_iteration = reporter.get_previous_checkpoint(iteration)
        # Find closest checkpoint
        if iteration != checkpoint_iteration:
            logger.debug("Last known checkpoint at iteration {0}. "
                         "Restoring from iteration {0} instead of {1}".format(checkpoint_iteration, iteration))
            iteration = checkpoint_iteration
        thermodynamic_states, unsampled_states = reporter.read_thermodynamic_states()
        sampler_states = reporter.read_sampler_states(iteration=iteration)
        state_indices = reporter.read_replica_thermodynamic_states(iteration=iteration)
        energy_thermodynamic_states, energy_unsampled_states = reporter.read_energies(iteration=iteration)
        n_accepted_matrix, n_proposed_matrix = reporter.read_mixing_statistics(iteration=iteration)
        metadata = reporter.read_dict('metadata', storage='checkpoint')

        # Close reading reporter.
        reporter.close()

        # Assign attributes.
        repex._iteration = iteration
        repex._thermodynamic_states = thermodynamic_states
        repex._unsampled_states = unsampled_states
        repex._sampler_states = sampler_states
        repex._replica_thermodynamic_states = state_indices
        repex._energy_thermodynamic_states = energy_thermodynamic_states
        repex._energy_unsampled_states = energy_unsampled_states
        repex._n_accepted_matrix = n_accepted_matrix
        repex._n_proposed_matrix = n_proposed_matrix
        repex._metadata = metadata

        # We open the reporter only in node 0.
        repex._reporter = Reporter(storage_base, open_mode=None)
        mpi.run_single_node(0, repex._reporter.open, mode='a',
                            broadcast_result=False, sync_nodes=False)
        return repex

    # -------------------------------------------------------------------------
    # Public properties.
    # -------------------------------------------------------------------------

    @property
    def n_replicas(self):
        """The number of replicas (read-only)."""
        if self._thermodynamic_states is None:
            return 0
        else:
            return len(self._thermodynamic_states)

    @property
    def iteration(self):
        """The current iteration of the simulation (read-only).

        If the simulation has not been created yet, this is None.

        """
        return self._iteration

    @property
    def mcmc_moves(self):
        """A copy of the MCMCMoves used to propagate the simulation.

        This can be set only before creation.

        """
        return copy.deepcopy(self._mcmc_moves)

    @mcmc_moves.setter
    def mcmc_moves(self, new_value):
        if self._thermodynamic_states is not None:
            # We can't modify representation of the MCMCMoves because it's
            # impossible to delete groups/variables from an NetCDF file. We
            # could support this by JSONizing the dict serialization and
            # store it as a string instead, if we needed this.
            raise RuntimeError('Cannot modify MCMCMoves after creation.')
        # If this is a single MCMCMove, it'll be transformed to a list in create().
        self._mcmc_moves = copy.deepcopy(new_value)

    @property
    def sampler_states(self):
        """A copy of the sampler states at the current iteration.

        This can be set only before running.
        """
        return copy.deepcopy(self._sampler_states)

    @sampler_states.setter
    def sampler_states(self, value):
        if self._iteration != 0:
            raise RuntimeError('Sampler states can be assigned only between '
                               'create() and run().')
        if len(value) != self.n_replicas:
            raise ValueError('Passed {} sampler states for {} replicas'.format(
                len(value), self.n_replicas))

        # Update sampler state in the object and on storage.
        self._sampler_states = copy.deepcopy(value)
        mpi.run_single_node(0, self._reporter.write_sampler_states,
                            self._sampler_states, self._iteration)

    class _StoredProperty(object):
        """Descriptor of a property stored as an option."""
        def __init__(self, option_name):
            self._option_name = option_name

        def __get__(self, instance, owner_class=None):
            return getattr(instance, '_' + self._option_name)

        def __set__(self, instance, new_value):
            if (self._option_name == 'replica_mixing_scheme' and
                        new_value not in ReplicaExchange._SUPPORTED_MIXING_SCHEMES):
                raise ValueError(("Unknown replica mixing scheme '{}'. Supported values "
                                  "are {}.").format(new_value, self._SUPPORTED_MIXING_SCHEMES))
            setattr(instance, '_' + self._option_name, new_value)
            mpi.run_single_node(0, instance._store_options)

    number_of_iterations = _StoredProperty('number_of_iterations')
    replica_mixing_scheme = _StoredProperty('replica_mixing_scheme')

    @property
    def metadata(self):
        """A copy of the metadata passed on creation (read-only)."""
        return copy.deepcopy(self._metadata)

    # -------------------------------------------------------------------------
    # Main public interface.
    # -------------------------------------------------------------------------

    def create(self, thermodynamic_states, sampler_states, storage_base,
               unsampled_thermodynamic_states=None, metadata=None, checkpoint_interval=10):
        """Create new replica-exchange simulation.

        Parameters
        ----------
        thermodynamic_states : list of openmmtools.states.ThermodynamicState
            Thermodynamic states to simulate, where one replica is allocated per state.
            Each state must have a system with the same number of atoms.
        sampler_states : openmmtools.states.SamplerState or list
            One or more sets of initial sampler states. If a list of SamplerStates,
            they will be assigned to replicas in a round-robin fashion.
        storage_base : str
            The base path to the storage files. In the future this will be able
            to take a Reporter.
        unsampled_thermodynamic_states : list of openmmtools.states.ThermodynamicState, optional
            These are ThermodynamicStates that are not propagated, but their
            reduced potential is computed at each iteration for each replica.
            These energy can be used as data for reweighting schemes (default
            is None).
        metadata : dict, optional
           Simulation metadata to be stored in the file.
        checkpoint_interval : int, optional,
            Frequency at which checkpoint information is written to file relative to the iteration.
            Simulations can be resumed from any checkpoint iteration.
            e.g. explicit solvent coordinates are written only at checkpoints, but energies are written every iteration
            Setting this to 1 will make every iteration a checkpoint, but will increase the IO time, and checkpoint file
                size
            (default is 10)

        """
        # Check if netcdf files exist. This is run only on MPI node 0 and
        # broadcasted. This is to avoid the case where the other nodes
        # arrive to this line after node 0 has already created the storage
        # file, causing an error.
        files_exist = False
        for extension in Reporter.storage_extensions():
            storage_path = storage_base + extension
            if mpi.run_single_node(0, self._does_file_exist, storage_path, broadcast_result=True):
                files_exist = True
        if files_exist:
            raise RuntimeError("Storage files with base {} already exists; cowardly "
                               "refusing to overwrite.".format(storage_base))

        # Make sure sampler_states is an iterable of SamplerStates for later.
        if isinstance(sampler_states, mmtools.states.SamplerState):
            sampler_states = [sampler_states]

        # Make sure there are no more sampler states than thermodynamic states.
        if len(sampler_states) > len(thermodynamic_states):
            raise ValueError('Passed {} SamplerStates but only {} ThermodynamicStates'.format(
                len(sampler_states), len(thermodynamic_states)))

        # Make sure all states have same number of particles. We don't
        # currently support writing storage with different n_particles
        n_particles = thermodynamic_states[0].n_particles
        for states in [thermodynamic_states, sampler_states]:
            for state in states:
                if state.n_particles != n_particles:
                    raise ValueError('All ThermodynamicStates and SamplerStates must '
                                     'have the same number of particles')

        # Handle default argument for metadata and add default simulation title.
        default_title = ('Replica-exchange simulation created using ReplicaExchange class '
                         'of yank.repex.py on {}'.format(time.asctime(time.localtime())))
        if metadata is None:
            metadata = dict(title=default_title)
        elif 'title' not in metadata:
            metadata['title'] = default_title
        self._metadata = metadata

        # Save thermodynamic states. This sets n_replicas.
        self._thermodynamic_states = copy.deepcopy(thermodynamic_states)

        # Handle default unsampled thermodynamic states.
        if unsampled_thermodynamic_states is None:
            self._unsampled_states = []
        else:
            self._unsampled_states = copy.deepcopy(unsampled_thermodynamic_states)

        # Distribute sampler states to replicas in a round-robin fashion.
        self._sampler_states = [copy.deepcopy(sampler_states[i % len(sampler_states)])
                                for i in range(self.n_replicas)]

        # Map each thermodynamic state to a replica. Replica i at each iteration is
        # in ThermodynamicState thermodynamic_states[replica_thermodynamic_states[i]]
        # and SamplerState sampler_states[i]. During mixing, we exchange the indices
        # of the ThermodynamicState, but we keep the SamplerStates (i.e. positions,
        # velocities, box_vectors) bound to the same replica.
        self._replica_thermodynamic_states = np.array([i for i in range(self.n_replicas)], np.int64)

        # Assign default system box vectors if None has been specified.
        for replica_id, thermodynamic_state_id in enumerate(self._replica_thermodynamic_states):
            sampler_state = self._sampler_states[replica_id]
            if sampler_state.box_vectors is not None:
                continue
            thermodynamic_state = self._thermodynamic_states[thermodynamic_state_id]
            sampler_state.box_vectors = thermodynamic_state.system.getDefaultPeriodicBoxVectors()

        # Ensure there is an MCMCMove for each thermodynamic state.
        if isinstance(self._mcmc_moves, mmtools.mcmc.MCMCMove):
            self._mcmc_moves = [copy.deepcopy(self._mcmc_moves) for _ in range(self.n_replicas)]
        elif len(self._mcmc_moves) != self.n_replicas:
            raise RuntimeError('The number of MCMCMoves ({}) and ThermodynamicStates ({}) must '
                               'be the same.'.format(len(self._mcmc_moves), self.n_replicas))

        # Reset iteration counter.
        self._iteration = 0

        # Reset statistics.
        # _n_accepted_matrix[i][j] is the number of swaps proposed between thermodynamic states i and j.
        # _n_proposed_matrix[i][j] is the number of swaps proposed between thermodynamic states i and j.
        self._n_accepted_matrix = np.zeros([self.n_replicas, self.n_replicas], np.int64)
        self._n_proposed_matrix = np.zeros([self.n_replicas, self.n_replicas], np.int64)

        # Allocate memory for energy matrix. energy_thermodynamic/unsampled_states[k][l]
        # is the reduced potential computed at the positions of SamplerState sampler_states[k]
        # and ThermodynamicState thermodynamic/unsampled_states[l].
        self._energy_thermodynamic_states = np.zeros([self.n_replicas, self.n_replicas], np.float64)
        self._energy_unsampled_states = np.zeros([self.n_replicas, len(self._unsampled_states)], np.float64)

        # Display papers to be cited.
        self._display_citations()

        # Initialize reporter file.
        self._reporter = Reporter(storage_base, open_mode=None, checkpoint_interval=checkpoint_interval)  # This is open only in node 0.
        self._initialize_reporter()

    @mmtools.utils.with_timer('Minimizing all replicas')
    def minimize(self, tolerance=1.0*unit.kilojoules_per_mole/unit.nanometers,
                 max_iterations=0):
        """Minimize all replicas.

        Minimized positions are stored at the end.

        Parameters
        ----------
        tolerance : simtk.unit.Quantity, optional
            Minimization tolerance (units of energy/mole/length, default is
            1.0 * unit.kilojoules_per_mole / unit.nanometers).
        max_iterations : int, optional
            Maximum number of iterations for minimization. If 0, minimization
            continues until converged.

        """
        # Check that simulation has been created.
        if self.n_replicas == 0:
            raise RuntimeError('Cannot minimize replicas. The simulation must be created first.')

        logger.debug("Minimizing all replicas...")

        # Distribute minimization across nodes. Only node 0 will get all positions.
        # The other nodes, only need the positions that they use for propagation and
        # computation of the energy matrix entries.
        minimized_positions, sampler_state_ids = mpi.distribute(self._minimize_replica, range(self.n_replicas),
                                                                tolerance, max_iterations,
                                                                send_results_to=0)

        # Update all sampler states. For non-0 nodes, this will update only the
        # sampler states associated to the replicas propagated by this node.
        for sampler_state_id, minimized_pos in zip(sampler_state_ids, minimized_positions):
            self._sampler_states[sampler_state_id].positions = minimized_pos

        # Save the stored positions in the storage
        mpi.run_single_node(0, self._reporter.write_sampler_states, self._sampler_states, self._iteration)

    def equilibrate(self, n_iterations, mcmc_moves=None):
        """Equilibrate all replicas.

        This does not increase the iteration counter. The equilibrated
        positions are stored at the end.

        Parameters
        ----------
        n_iterations : int
            Number of equilibration iterations.
        mcmc_moves : MCMCMove or list of MCMCMove, optional
            Optionally, the MCMCMoves to use for equilibration can be
            different from the ones used in production.

        """
        # Check that simulation has been created.
        if self.n_replicas == 0:
            raise RuntimeError('Cannot minimize replicas. The simulation must be created first.')

        # If no MCMCMove is specified, use the ones for production.
        if mcmc_moves is None:
            mcmc_moves = self._mcmc_moves

        # Make sure there is one MCMCMove per thermodynamic state.
        if isinstance(mcmc_moves, mmtools.mcmc.MCMCMove):
            mcmc_moves = [copy.deepcopy(mcmc_moves) for _ in range(self.n_replicas)]
        elif len(mcmc_moves) != self.n_replicas:
            raise RuntimeError('The number of MCMCMoves ({}) and ThermodynamicStates ({}) for equilibration'
                               ' must be the same.'.format(len(self._mcmc_moves), self.n_replicas))

        # Temporarily set the equilibration MCMCMoves.
        production_mcmc_moves = self._mcmc_moves
        self._mcmc_moves = mcmc_moves
        for iteration in range(n_iterations):
            logger.debug("Equilibration iteration {}/{}".format(iteration, n_iterations))
            self._propagate_replicas()

        # Restore production MCMCMoves.
        self._mcmc_moves = production_mcmc_moves

        # Update stored positions.
        mpi.run_single_node(0, self._reporter.write_sampler_states, self._sampler_states, self._iteration)

    def run(self, n_iterations=None):
        """Run the replica-exchange simulation.

        This runs at most `number_of_iterations` iterations. Use `extend()`
        to pass the limit.

        Parameters
        ----------
        n_iterations : int, optional
           If specified, only at most the specified number of iterations
           will be run (default is None).

        """
        # If this is the first iteration, compute and store the
        # starting energies of the minimized/equilibrated structures.
        if self._iteration == 0:
            self._compute_energies()
            mpi.run_single_node(0, self._reporter.write_energies, self._energy_thermodynamic_states,
                                self._energy_unsampled_states, self._iteration)
            self._check_nan_energy()

        timer = mmtools.utils.Timer()
        timer.start('Run ReplicaExchange')
        run_initial_iteration = self._iteration

        # Handle default argument and determine number of iterations to run.
        if n_iterations is None:
            iteration_limit = self._number_of_iterations - self._iteration
        else:
            iteration_limit = min(self._iteration + n_iterations, self._number_of_iterations)

        while self._iteration < iteration_limit:
            # Increment iteration counter.
            self._iteration += 1

            logger.debug('Iteration {}/{}'.format(self._iteration, iteration_limit))
            timer.start('Iteration')

            # Attempt replica swaps to sample from equilibrium permuation of
            # states associated with replicas. This step synchronizes replicas.
            self._replica_thermodynamic_states = self._mix_replicas()

            # Propagate replicas.
            self._propagate_replicas()

            # Compute energies of all replicas at all states.
            self._compute_energies()

            # Write iteration to storage file.
            self._report_iteration()

            # Show timing statistics if debug level is activated.
            if logger.isEnabledFor(logging.DEBUG):
                iteration_time = timer.stop('Iteration')
                partial_total_time = timer.partial('Run ReplicaExchange')
                time_per_iteration = partial_total_time / (self._iteration - run_initial_iteration)
                estimated_time_remaining = time_per_iteration * (iteration_limit - self._iteration)
                estimated_total_time = time_per_iteration * iteration_limit
                estimated_finish_time = partial_total_time + estimated_time_remaining
                logger.debug("Iteration took {:.3f}s.".format(iteration_time))
                logger.debug("Estimated completion in {}, at {} (consuming total wall clock time {}).".format(
                    str(datetime.timedelta(seconds=estimated_time_remaining)), time.ctime(estimated_finish_time),
                    str(datetime.timedelta(seconds=estimated_total_time))))

            # Perform sanity checks to see if we should terminate here.
            self._check_nan_energy()

    def extend(self, n_iterations):
        """Extend the simulation by the given number of iterations.

        Contrarily to `run()`, this will extend the number of iterations past
        `number_of_iteration` if requested.

        Parameters
        ----------
        n_iterations : int
           The number of iterations to run.

        """
        if self._iteration + n_iterations > self._number_of_iterations:
            self.number_of_iterations = self._iteration + n_iterations
        self.run(n_iterations)

    def __repr__(self):
        """Return a 'formal' representation that can be used to reconstruct the class, if possible."""
        # TODO: Can we make this a more useful expression?
        return "<instance of ReplicaExchange>"

    def __str__(self):
        """
        Show an 'informal' human-readable representation of the replica-exchange simulation.

        """
        r = "Replica-exchange simulation\n"
        r += "\n"
        r += "{:d} replicas\n".format(self.nreplicas)
        r += "{:d} coordinate sets provided\n".format(len(self.provided_positions))
        r += "file store: {:s}\n".format(self.store_filename)
        r += "initialized: {:s}\n".format(self._initialized)
        r += "\n"
        r += "PARAMETERS\n"
        r += "collision rate: {:s}\n".format(self.collision_rate)
        r += "relative constraint tolerance: {:s}\n".format(self.constraint_tolerance)
        r += "timestep: {:s}\n".format(self.timestep)
        r += "number of steps/iteration: {:d}\n".format(self.nsteps_per_iteration)
        r += "number of iterations: {:d}\n".format(self.number_of_iterations)
        if self.extend_simulation:
            r += "Iterations extending existing data.\n"
        r += "equilibration timestep: {:s}\n".format(self.equilibration_timestep)
        r += "number of equilibration iterations: {:d}\n".format(self.number_of_equilibration_iterations)
        r += "\n"

        return r

    def __del__(self):
        # The reporter could be None if ReplicaExchange was not created.
        if self._reporter is not None:
            mpi.run_single_node(0, self._reporter.close)

    # -------------------------------------------------------------------------
    # Internal-usage.
    # -------------------------------------------------------------------------

    def _check_nan_energy(self):
        """Checks that energies are finite and abort otherwise.

        Checks both sampled and unsampled thermodynamic states.

        """
        # Check thermodynamic state energies.
        if np.any(np.isnan(self._energy_thermodynamic_states)) or np.any(np.isnan(self._energy_unsampled_states)):
            # Find faulty replicas to create error message.
            faulty_replicas = set()

            # Check sampled thermodynamic states first.
            state_type = 'thermodynamic state'
            for replica_id in range(self.n_replicas):
                if np.any(np.isnan(self._energy_thermodynamic_states[replica_id])):
                    faulty_replicas.add(replica_id)

            # If there are no NaNs in energies, the problem is in the unsampled states.
            if len(faulty_replicas) == 0:
                state_type = 'unsampled thermodynamic state'
                for replica_id in range(self.n_replicas):
                    if np.any(np.isnan(self._unsampled_states[replica_id])):
                        faulty_replicas.add(replica_id)

            # Raise exception.
            err_msg = "NaN encountered in {} energies for replicas {}".format(state_type, faulty_replicas)
            logger.error(err_msg)
            raise RuntimeError(err_msg)

    def _display_citations(self):
        """Display papers to be cited."""
        # TODO Add original citations for various replica-exchange schemes.
        # TODO Show subset of OpenMM citations based on what features are being used.
        openmm_citations = """\
        Friedrichs MS, Eastman P, Vaidyanathan V, Houston M, LeGrand S, Beberg AL, Ensign DL, Bruns CM, and Pande VS. Accelerating molecular dynamic simulations on graphics processing unit. J. Comput. Chem. 30:864, 2009. DOI: 10.1002/jcc.21209
        Eastman P and Pande VS. OpenMM: A hardware-independent framework for molecular simulations. Comput. Sci. Eng. 12:34, 2010. DOI: 10.1109/MCSE.2010.27
        Eastman P and Pande VS. Efficient nonbonded interactions for molecular dynamics on a graphics processing unit. J. Comput. Chem. 31:1268, 2010. DOI: 10.1002/jcc.21413
        Eastman P and Pande VS. Constant constraint matrix approximation: A robust, parallelizable constraint method for molecular simulations. J. Chem. Theor. Comput. 6:434, 2010. DOI: 10.1021/ct900463w"""

        gibbs_citations = """\
        Chodera JD and Shirts MR. Replica exchange and expanded ensemble simulations as Gibbs sampling: Simple improvements for enhanced mixing. J. Chem. Phys., 135:194110, 2011. DOI:10.1063/1.3660669"""

        mbar_citations = """\
        Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states. J. Chem. Phys. 129:124105, 2008. DOI: 10.1063/1.2978177"""

        print("Please cite the following:")
        print("")
        print(openmm_citations)
        if self._replica_mixing_scheme == 'swap-all':
            print(gibbs_citations)

    # -------------------------------------------------------------------------
    # Internal-usage: Initialization and storage utilities.
    # -------------------------------------------------------------------------

    @staticmethod
    def _does_file_exist(file_path):
        """Check if there is a file at the given path."""
        return os.path.exists(file_path) and os.path.getsize(file_path) > 0

    @mpi.on_single_node(rank=0, broadcast_result=False, sync_nodes=True)
    def _initialize_reporter(self):
        """Initialize the reporter and store initial information.

        This is executed only on MPI node 0 and it is blocking. This is to
        avoid the case where the other nodes skip ahead and try to read
        from a file that hasn't been created yet.

        """
        self._reporter.open(mode='w')
        self._reporter.write_thermodynamic_states(self._thermodynamic_states,
                                                  self._unsampled_states)

        # Store run metadata and ReplicaExchange options.
        self._store_options()
        self._reporter.write_dict('metadata', self._metadata, storage='checkpoint')

        # Store initial conditions. This forces the storage to be synchronized.
        self._report_iteration()

    @mpi.on_single_node(rank=0, broadcast_result=False, sync_nodes=False)
    @mpi.delayed_termination
    @mmtools.utils.with_timer('Writing iteration information to storage')
    def _report_iteration(self):
        """Store positions, states, and energies of current iteration.

        This is executed only on MPI node 0 and it's not blocking. The
        termination is delayed so that the file is not written only with
        partial data if the program gets interrupted.

        """
        self._reporter.write_sampler_states(self._sampler_states, self._iteration)
        self._reporter.write_replica_thermodynamic_states(self._replica_thermodynamic_states, self._iteration)
        self._reporter.write_mcmc_moves(self._mcmc_moves)  # MCMCMoves can store internal statistics.
        self._reporter.write_energies(self._energy_thermodynamic_states, self._energy_unsampled_states,
                                      self._iteration)
        self._reporter.write_mixing_statistics(self._n_accepted_matrix, self._n_proposed_matrix, self._iteration)
        self._reporter.write_timestamp(self._iteration)
        self._reporter.sync()

    def _store_options(self):
        """Store __init__ parameters (beside MCMCMoves) in storage file."""
        logger.debug("Storing general ReplicaExchange options...")

        # Inspect __init__ parameters to store.
        parameter_names, _, _, defaults = inspect.getargspec(self.__init__)

        # Retrieve and store options.
        options_to_store = {parameter_name: getattr(self, '_' + parameter_name)
                            for parameter_name in parameter_names[-len(defaults):]}
        # We store the MCMCMoves separately.
        options_to_store.pop('mcmc_moves')
        self._reporter.write_dict('options', options_to_store, storage='checkpoint')

    # -------------------------------------------------------------------------
    # Internal-usage: Distributed tasks.
    # -------------------------------------------------------------------------

    @mmtools.utils.with_timer('Propagating all replicas')
    def _propagate_replicas(self):
        """Propagate all replicas."""
        # TODO  Report on efficiency of dyanmics (fraction of time wasted to overhead).
        logger.debug("Propagating all replicas...")

        # Distribute propagation across nodes. Only node 0 will get all positions
        # and box vectors. The other nodes, only need the positions that they use
        # for propagation and computation of the energy matrix entries.
        propagated_states, replica_ids = mpi.distribute(self._propagate_replica, range(self.n_replicas),
                                                        send_results_to=0)

        # Update all sampler states. For non-0 nodes, this will update only the
        # sampler states associated to the replicas propagated by this node.
        for replica_id, propagated_state in zip(replica_ids, propagated_states):
            propagated_positions, propagated_box_vectors = propagated_state  # Unpack.
            self._sampler_states[replica_id].positions = propagated_positions
            self._sampler_states[replica_id].box_vectors = propagated_box_vectors

        # Gather all MCMCMoves statistics. All nodes must have these up-to-date
        # since they are tied to the ThermodynamicState, not the replica.
        all_statistics = mpi.distribute(self._get_replica_move_statistics, range(self.n_replicas),
                                        send_results_to='all')
        for replica_id in range(self.n_replicas):
            if len(all_statistics[replica_id]) > 0:
                thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
                self._mcmc_moves[thermodynamic_state_id].statistics = all_statistics[replica_id]

    def _propagate_replica(self, replica_id):
        """Propagate thermodynamic state associated to the given replica."""
        # Retrieve thermodynamic, sampler states, and MCMC move of this replica.
        thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
        thermodynamic_state = self._thermodynamic_states[thermodynamic_state_id]
        mcmc_move = self._mcmc_moves[thermodynamic_state_id]
        sampler_state = self._sampler_states[replica_id]

        # Apply MCMC move.
        try:
            mcmc_move.apply(thermodynamic_state, sampler_state)
        except mmtools.mcmc.IntegratorMoveError as e:
            # Save NaNnig context and MCMove before aborting.
            prefix = 'nan-error-logs/iteration{}-replica{}-state{}'.format(
                self._iteration, replica_id, thermodynamic_state_id)
            e.serialize_error(prefix)
            raise

        # Return new positions and box vectors.
        return sampler_state.positions, sampler_state.box_vectors

    def _get_replica_move_statistics(self, replica_id):
        """Return the statistics of the MCMCMove currently associated to this replica."""
        thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
        mcmc_move = self._mcmc_moves[thermodynamic_state_id]

        try:
            move_statistics = mcmc_move.statistics
        except AttributeError:
            move_statistics = {}

        return move_statistics

    def _minimize_replica(self, replica_id, tolerance, max_iterations):
        """Minimize the specified replica."""
        # Retrieve thermodynamic and sampler states.
        thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
        thermodynamic_state = self._thermodynamic_states[thermodynamic_state_id]
        sampler_state = self._sampler_states[replica_id]

        # Retrieve a context. Any Integrator works.
        context, integrator = mmtools.cache.global_context_cache.get_context(thermodynamic_state)

        # Set initial positions and box vectors.
        sampler_state.apply_to_context(context)

        # Compute the initial energy of the system for logging.
        initial_energy = thermodynamic_state.reduced_potential(context)
        logger.debug('Replica {}/{}: initial energy {:8.3f}kT'.format(
            replica_id + 1, self.n_replicas, initial_energy))

        # Minimize energy.
        openmm.LocalEnergyMinimizer.minimize(context, tolerance, max_iterations)

        # Get the minimized positions.
        sampler_state.update_from_context(context)

        # Compute the final energy of the system for logging.
        final_energy = thermodynamic_state.reduced_potential(sampler_state)
        logger.debug('Replica {}/{}: final energy {:8.3f}kT'.format(
            replica_id + 1, self.n_replicas, final_energy))

        # Return minimized positions.
        return sampler_state.positions

    @mmtools.utils.with_timer('Computing energy matrix')
    def _compute_energies(self):
        """Compute energies of all replicas at all states."""

        # Distribute energy computation across nodes. Only node 0 receives
        # all the energies since it needs to store them and mix states.
        new_energies, replica_ids = mpi.distribute(self._compute_replica_energies, range(self.n_replicas),
                                                   send_results_to=0)

        # Update energy matrices. Non-0 nodes update only the energies computed by this replica.
        for replica_id, energies in zip(replica_ids, new_energies):
            energy_thermodynamic_states, energy_unsampled_states = energies  # Unpack.
            self._energy_thermodynamic_states[replica_id] = energy_thermodynamic_states
            self._energy_unsampled_states[replica_id] = energy_unsampled_states

    def _compute_replica_energies(self, replica_id):
        """Compute the energy for the replica in every ThermodynamicState."""
        # Initialize replica energies for each thermodynamic state.
        energy_thermodynamic_states = np.zeros(self.n_replicas)
        energy_unsampled_states = np.zeros(len(self._unsampled_states))

        # Retrieve sampler state associated to this replica.
        sampler_state = self._sampler_states[replica_id]

        # Compute energy for all thermodynamic states.
        for energies, states in [(energy_thermodynamic_states, self._thermodynamic_states),
                                 (energy_unsampled_states, self._unsampled_states)]:
            for i, state in enumerate(states):
                # Get the context, any Integrator works.
                context, integrator = mmtools.cache.global_context_cache.get_context(state)

                # Update positions and box vectors. We don't need
                # to set Context velocities for the potential.
                sampler_state.apply_to_context(context, ignore_velocities=True)

                # Compute energy.
                energies[i] = state.reduced_potential(context)

        # Return the new energies.
        return energy_thermodynamic_states, energy_unsampled_states

    # -------------------------------------------------------------------------
    # Internal-usage: Replicas mixing.
    # -------------------------------------------------------------------------

    _SUPPORTED_MIXING_SCHEMES = frozenset(['swap-all', 'swap-neighbors', 'none'])

    @mpi.on_single_node(0, broadcast_result=True)
    def _mix_replicas(self):
        """Attempt to swap replicas according to user-specified scheme."""
        logger.debug("Mixing replicas...")

        # Reset storage to keep track of swap attempts this iteration.
        self._n_accepted_matrix[:, :] = 0
        self._n_proposed_matrix[:, :] = 0

        # Perform swap attempts according to requested scheme.
        assert self._replica_mixing_scheme in self._SUPPORTED_MIXING_SCHEMES
        with mmtools.utils.time_it('Mixing of replicas'):
            if self._replica_mixing_scheme == 'swap-neighbors':
                self._mix_neighboring_replicas()
            elif self._replica_mixing_scheme == 'swap-all':
                # Try to use cython-accelerated mixing code if possible,
                # otherwise fall back to Python-accelerated code.
                try:
                    self._mix_all_replicas_cython()
                except ValueError as e:
                    logger.warning(e.message)
                    self._mix_all_replicas()
            else:
                assert self._replica_mixing_scheme == 'none'

        # Determine fraction of swaps accepted this iteration.
        n_swaps_proposed = self._n_proposed_matrix.sum()
        n_swaps_accepted = self._n_accepted_matrix.sum()
        swap_fraction_accepted = 0.0
        if n_swaps_proposed > 0:
            # TODO drop casting to float when dropping Python 2 support.
            swap_fraction_accepted = float(n_swaps_accepted) / n_swaps_proposed
        logger.debug("Accepted {}/{} attempted swaps ({:.1f}%)".format(n_swaps_accepted, n_swaps_proposed,
                                                                       swap_fraction_accepted * 100.0))

        # Return new states indices for MPI broadcasting.
        return self._replica_thermodynamic_states

    def _mix_all_replicas_cython(self):
        """Exchange all replicas with Cython-accelerated code."""
        from .mixing._mix_replicas import _mix_replicas_cython

        replica_states = md.utils.ensure_type(self._replica_thermodynamic_states, np.int64, 1, "Replica States")
        u_kl = md.utils.ensure_type(self._energy_thermodynamic_states, np.float64, 2, "Reduced Potentials")
        n_proposed_matrix = md.utils.ensure_type(self._n_proposed_matrix, np.int64, 2, "Nij Proposed Swaps")
        n_accepted_matrix = md.utils.ensure_type(self._n_accepted_matrix, np.int64, 2, "Nij Accepted Swaps")
        _mix_replicas_cython(self.n_replicas**4, self.n_replicas, replica_states,
                             u_kl, n_proposed_matrix, n_accepted_matrix)

        self._replica_thermodynamic_states = replica_states
        self._n_proposed_matrix = n_proposed_matrix
        self._n_accepted_matrix = n_accepted_matrix

    def _mix_all_replicas(self):
        """Exchange all replicas with Python."""
        # Determine number of swaps to attempt to ensure thorough mixing.
        # TODO: Replace this with analytical result computed to guarantee sufficient mixing, or
        # TODO:     adjust it  based on how many we can afford to do and not have mixing take a
        # TODO:     substantial fraction of iteration time.
        nswap_attempts = self.n_replicas**5  # Number of swaps to attempt (ideal, but too slow!)
        nswap_attempts = self.n_replicas**3  # Best compromise for pure Python?

        logger.debug("Will attempt to swap all pairs of replicas, using a total of %d attempts." % nswap_attempts)

        # Attempt swaps to mix replicas.
        for swap_attempt in range(nswap_attempts):
            # Choose random replicas uniformly to attempt to swap.
            replica_i = np.random.randint(self.n_replicas)
            replica_j = np.random.randint(self.n_replicas)
            self._attempt_swap(replica_i, replica_j)

    def _mix_neighboring_replicas(self):
        """Attempt exchanges between neighboring replicas only."""
        logger.debug("Will attempt to swap only neighboring replicas.")

        # Attempt swaps of pairs of replicas using traditional scheme (e.g. [0,1], [2,3], ...).
        offset = np.random.randint(2)  # Offset is 0 or 1.
        for thermodynamic_state_i in range(offset, self.n_replicas-1, 2):
            thermodynamic_state_j = thermodynamic_state_i + 1  # Neighboring state.

            # Determine which replicas currently hold the thermodynamic states.
            replica_i = np.where(self._replica_thermodynamic_states == thermodynamic_state_i)
            replica_j = np.where(self._replica_thermodynamic_states == thermodynamic_state_j)
            self._attempt_swap(replica_i, replica_j)

    def _attempt_swap(self, replica_i, replica_j):
        """Attempt a single exchange between two replicas."""
        # Determine the thermodynamic states associated to these replicas.
        thermodynamic_state_i = self._replica_thermodynamic_states[replica_i]
        thermodynamic_state_j = self._replica_thermodynamic_states[replica_j]

        # Compute log probability of swap.
        energy_ij = self._energy_thermodynamic_states[replica_i, thermodynamic_state_j]
        energy_ji = self._energy_thermodynamic_states[replica_j, thermodynamic_state_i]
        energy_ii = self._energy_thermodynamic_states[replica_i, thermodynamic_state_i]
        energy_jj = self._energy_thermodynamic_states[replica_j, thermodynamic_state_j]
        log_p_accept = - (energy_ij + energy_ji) + energy_ii + energy_jj

        # Record that this move has been proposed.
        self._n_proposed_matrix[thermodynamic_state_i, thermodynamic_state_j] += 1
        self._n_proposed_matrix[thermodynamic_state_j, thermodynamic_state_i] += 1

        # Accept or reject.
        if log_p_accept >= 0.0 or np.random.rand() < math.exp(log_p_accept):
            # Swap states in replica slots i and j.
            self._replica_thermodynamic_states[replica_i] = thermodynamic_state_j
            self._replica_thermodynamic_states[replica_j] = thermodynamic_state_i
            # Accumulate statistics.
            self._n_accepted_matrix[thermodynamic_state_i, thermodynamic_state_j] += 1
            self._n_accepted_matrix[thermodynamic_state_j, thermodynamic_state_i] += 1


# ==============================================================================
# PARALLEL TEMPERING
# ==============================================================================

class ParallelTempering(ReplicaExchange):
    """Parallel tempering simulation facility.

    This class provides a facility for parallel tempering simulations. It
    is a subclass of ReplicaExchange, but provides efficiency improvements
    for parallel tempering simulations, so should be preferred for this type
    of simulation. In particular, this makes use of the fact that the reduced
    potentials are linear in inverse temperature.

    Examples
    --------

    Create the system.

    >>> from simtk import unit
    >>> from openmmtools import testsystems, states, mcmc
    >>> testsystem = testsystems.AlanineDipeptideImplicit()

    Create thermodynamic states for parallel tempering with exponentially-spaced schedule.

    >>> n_replicas = 3  # Number of temperature replicas.
    >>> T_min = 298.0 * unit.kelvin  # Minimum temperature.
    >>> T_max = 600.0 * unit.kelvin  # Maximum temperature.
    >>> reference_state = states.ThermodynamicState(system=testsystem.system, temperature=T_min)

    Initialize simulation object with options. Run with a GHMC integrator.

    >>> move = mcmc.GHMCMove(timestep=2.0*unit.femtoseconds, n_steps=50)
    >>> simulation = ParallelTempering(mcmc_moves=move, number_of_iterations=2)

    Create simulation with its storage file (in a temporary directory) and run.

    >>> storage_base_path = tempfile.NamedTemporaryFile(delete=False).name
    >>> simulation.create(thermodynamic_states=thermodynamic_states,
    >>>                   sampler_states=states.SamplerState(testsystem.positions),
    ...                   storage_base=storage_base_path, min_temperature=T_min,
    ...                   max_temperature=T_max, n_temperatures=n_replicas,
    ...                   checkpoint_interval=1)
    >>> simulation.run(n_iterations=1)

    Clean up.

    >>> os.remove(storage_path)

    """

    def create(self, thermodynamic_state, sampler_states, storage_base, min_temperature=None,
               max_temperature=None, n_temperatures=None, temperatures=None, metadata=None, checkpoint_interval=10):
        """Initialize a parallel tempering simulation object.

        Parameters
        ----------
        thermodynamic_state : openmmtools.states.ThermodynamicState
            Reference thermodynamic state that will be simulated at the given
            temperatures.
        sampler_states : openmmtools.states.SamplerState or list
            One or more sets of initial sampler states. If a list of SamplerStates,
            they will be assigned to replicas in a round-robin fashion.
        storage_base : str
            The base path to the storage files. In the future this will be able
            to take a Reporter class as well.
        min_temperature : simtk.unit.Quantity, optional
           Minimum temperature (units of temperature, default is None).
        max_temperature : simtk.unit.Quantity, optional
           Maximum temperature (units of temperature, default is None).
        n_temperatures : int, optional
           Number of exponentially-spaced temperatures between min_temperature
           and max_temperature (default is None).
        temperatures : list of simtk.unit.Quantity, optional
           If specified, this list of temperatures will be used instead of
           min_temperature, max_temperature, and n_temperatures (units of temeprature,
           default is None).
        metadata : dict, optional
           Simulation metadata to be stored in the file.
        checkpoint_interval : int, optional,
            Frequency at which checkpoint information is written to file relative to the iteration.
            Simulations can be resumed from any checkpoint iteration.
            e.g. explicit solvent coordinates are written only at checkpoints, but energies are written every iteration
            Setting this to 1 will make every iteration a checkpoint, but will increase the IO time, and checkpoint file
                size
            (default is 10)

        Notes
        -----
        Either (min_temperature, max_temperature, n_temperatures) must all be
        specified or the list of 'temperatures' must be specified.

        """
        # Create thermodynamic states from temperatures.
        if temperatures is not None:
            logger.debug("Using provided temperatures")
        elif min_temperature is not None and max_temperature is not None and n_temperatures is not None:
            # TODO drop casting to float when dropping Python 2 support.
            temperatures = [min_temperature + (max_temperature - min_temperature) *
                            (math.exp(i / float(n_temperatures-1)) - 1.0) / (math.e - 1.0)
                            for i in range(n_temperatures)]
            logger.debug('using temperatures {}'.format(temperatures))
        else:
            raise ValueError("Either 'temperatures' or 'min_temperature', 'max_temperature', "
                             "and 'n_temperatures' must be provided.")

        thermodynamic_states = [copy.deepcopy(thermodynamic_state) for _ in range(n_temperatures)]
        for state, temperature in zip(thermodynamic_states, temperatures):
            state.temperature = temperature

        # Override default title.
        default_title = ('Parallel tempering simulation created using ParallelTempering '
                         'class of yank.repex.py on {}'.format(time.asctime(time.localtime())))
        if metadata is None:
            metadata = dict(title=default_title)
        elif 'title' not in metadata:
            metadata['title'] = default_title

        # Initialize replica-exchange simlulation.
        super(ParallelTempering, self).create(thermodynamic_states, sampler_states,
                                              storage_base=storage_base, metadata=metadata,
                                              checkpoint_interval=checkpoint_interval)

    def _compute_replica_energies(self, replica_id):
        """Compute the energy for the replica at every temperature.

        Because only the temperatures differ among replicas, we replace the generic O(N^2)
        replica-exchange implementation with an O(N) implementation.

        """
        # Initialize replica energies for each thermodynamic state.
        replica_energies = np.zeros(self.n_replicas)

        # Retrieve sampler states associated to this replica.
        sampler_state = self._sampler_states[replica_id]

        # Thermodynamic state differ only by temperatures.
        reference_thermodynamic_state = self._thermodynamic_states[0]

        # Get the context, any Integrator works.
        context, integrator = mmtools.cache.global_context_cache.get_context(reference_thermodynamic_state)

        # Update positions and box vectors.
        sampler_state.apply_to_context(context)

        # Compute energy.
        reference_reduced_potential = reference_thermodynamic_state.reduced_potential(context)

        # Strip reference potential of reference state's beta.
        reference_beta = 1.0 / (mmtools.constants.kB * reference_thermodynamic_state.temperature)
        reference_reduced_potential /= reference_beta

        # Update potential energy by temperature.
        for thermodynamic_state_id, thermodynamic_state in enumerate(self._thermodynamic_states):
            beta = 1.0 / (mmtools.constants.kB * thermodynamic_state.temperature)
            replica_energies[replica_id, thermodynamic_state_id] = beta * reference_reduced_potential

        # Return the new energies.
        return replica_energies


# ==============================================================================
# MODULE INTERNAL USAGE UTILITIES
# ==============================================================================

class _DictYamlLoader(yaml.Loader):
    """PyYAML Loader that reads !Quantity tags."""
    def __init__(self, *args, **kwargs):
        super(_DictYamlLoader, self).__init__(*args, **kwargs)
        self.add_constructor(u'!Quantity', self.quantity_constructor)
        self.add_constructor(u'!ndarray', self.ndarray_constructor)

    @staticmethod
    def quantity_constructor(loader, node):
        loaded_mapping = loader.construct_mapping(node)
        data_unit = utils.quantity_from_string(loaded_mapping['unit'])
        data_value = loaded_mapping['value']
        return data_value * data_unit

    @staticmethod
    def ndarray_constructor(loader, node):
        loaded_mapping = loader.construct_mapping(node, deep=True)
        data_type = np.dtype(loaded_mapping['type'])
        data_shape = loaded_mapping['shape']
        data_values = loaded_mapping['values']
        data = np.ndarray(shape=data_shape, dtype=data_type)
        if 0 not in data_shape:
            data[:] = data_values
        return data


class _DictYamlDumper(yaml.Dumper):
    """PyYAML Dumper that handle simtk Quantities through !Quantity tags."""

    def __init__(self, *args, **kwargs):
        super(_DictYamlDumper, self).__init__(*args, **kwargs)
        self.add_representer(unit.Quantity, self.quantity_representer)
        self.add_representer(np.ndarray, self.ndarray_representer)

    @staticmethod
    def quantity_representer(dumper, data):
        data_unit = data.unit
        data_value = data / data_unit
        data_dump = dict(unit=str(data_unit), value=data_value)
        return dumper.represent_mapping(u'!Quantity', data_dump)

    @staticmethod
    def ndarray_representer(dumper, data):
        """Convert a numpy array to native Python types."""
        data_type = str(data.dtype)
        data_shape = data.shape
        data_values = data.tolist()
        data_dump = dict(type=data_type, shape=data_shape, values=data_values)
        return dumper.represent_mapping(u'!ndarray', data_dump)


# ==============================================================================
# MAIN AND TESTS
# ==============================================================================

if __name__ == "__main__":
    import doctest
    doctest.testmod()
