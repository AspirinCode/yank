#!/usr/local/bin/env python

# ==============================================================================
# MODULE DOCSTRING
# ==============================================================================

"""Replica-exchange simulation algorithms and specific variants.

This module provides a general facility for running replica-exchange simulations,
as well as derived classes for special cases such as parallel tempering (in which
the states differ only in temperature).

Provided classes include:

- ReplicaExchange
    Base class for general replica-exchange simulations.
- ParallelTempering
    Convenience subclass of ReplicaExchange for parallel tempering simulations
    (one System object, many temperatures).

COPYRIGHT

Written by John D. Chodera <jchodera@gmail.com> while at the University of
California Berkeley.

LICENSE

This code is licensed under the latest available version of the MIT License.

"""

# ==============================================================================
# GLOBAL IMPORTS
# ==============================================================================

from simtk import openmm
from simtk import unit

import os
import math
import copy
import time
import inspect
import datetime
import logging
import importlib
import collections
from distutils.version import StrictVersion

import numpy as np
import mdtraj as md
import netCDF4 as netcdf

import openmmtools as mmtools
from openmmtools.states import ThermodynamicState

from yank import utils, mpi, version

logger = logging.getLogger(__name__)


# ==============================================================================
# REPLICA EXCHANGE REPORTER
# ==============================================================================

class Reporter(object):
    """Handle storage write/read operations and different format conventions.

    You can use this object to programmatically inspect the data generated by
    ReplicaExchange.

    Parameters
    ----------
    storage : str
        The path to the file. In the future this will be able to take Storage
        classes as well.
    open_mode : str or None
        The mode of the file between 'r', 'w', and 'a' (or equivalently 'r+').
        If None, the storage file won't be open on construction, and a call to
        Reporter.open() will be needed before attempting read/write operations.

    """
    def __init__(self, storage, open_mode=None):
        self._storage_file_path = storage
        self._storage = None
        if open_mode is not None:
            self.open(open_mode)

    def is_open(self):
        """Return True if the Reporter is ready to read/write."""
        if self._storage is None:
            return False
        return self._storage.isopen()

    def open(self, mode='r'):
        """Open the storage file for reading/writing.

        This is not necessary if you have indicated in the constructor to open.

        Parameters
        ----------
        mode : str
            The mode of the file between 'r', 'w', and 'a' (or equivalently 'r+').

        """
        # Ensure we don't have already another file
        # open (possibly in a different mode).
        if self._storage is not None:
            self.close()

        # Open NetCDF 4 file for writing.
        ncfile = netcdf.Dataset(self._storage_file_path, mode, version='NETCDF4')

        # Create header if needed.
        if 'scalar' not in ncfile.dimensions:
            # Create common dimensions.
            ncfile.createDimension('scalar', 1)  # Scalar dimension.
            ncfile.createDimension('iteration', 0)  # Unlimited number of iterations.
            ncfile.createDimension('spatial', 3)  # Number of spatial dimensions.

            # Set global attributes.
            ncfile.application = 'YANK'
            ncfile.program = 'yank.py'
            ncfile.programVersion = version.short_version
            ncfile.Conventions = 'ReplicaExchange'
            ncfile.ConventionVersion = str(self._LATEST_CONVENTION_VERSION)

        self._storage = ncfile

    def close(self):
        """Close the storage file."""
        self._storage.sync()
        self._storage.close()
        self._storage = None

    def sync(self):
        """Force any buffer to be flushed to the file."""
        self._storage.sync()

    def __del__(self):
        """Synchronize and close the storage."""
        if self._storage is not None:
            self.close()

    @mmtools.utils.with_timer('Reading thermodynamic states from storage')
    def read_thermodynamic_states(self):
        """Retrieve the stored thermodynamic states.

        Returns
        -------
        thermodynamic_states : list of ThermodynamicStates
            The previously stored thermodynamic states. During the simulation
            these are swapped among replicas.
        unsampled_states : list of ThermodynamicState
            The previously stored unsampled thermodynamic states.

        See Also
        --------
        read_replica_thermodynamic_states

        """
        # Handle previous versions of the conventions.
        convention_version = StrictVersion(getattr(self._storage, 'ConventionVersion'))
        if convention_version <= StrictVersion('0.1'):
            return self._read_thermodynamic_states_0_1()

        # We have to parse the thermodynamic states first because the
        # unsampled states may refer to them for the serialized system.
        states = collections.OrderedDict([('thermodynamic_states', list()),
                                          ('unsampled_states', list())])

        # Read state information.
        for state_type, state_list in states.items():
            # Retrieve the group storing the states.
            try:
                ncgrp_states = self._storage.groups[state_type]
            except KeyError:
                # There may not be unsampled states.
                assert state_type == 'unsampled_states'
                continue

            # We keep looking for states until we can't find them anymore.
            state_id = 0
            while True:
                try:
                    serialized_state = self._read_dict(ncgrp_states.groups['state' + str(state_id)])
                except KeyError:
                    # There are no more stored states.
                    break

                # Find the thermodynamic state representation.
                serialized_thermodynamic_state = serialized_state
                while 'thermodynamic_state' in serialized_thermodynamic_state:
                    # The while loop is necessary for nested CompoundThermodynamicStates.
                    serialized_thermodynamic_state = serialized_state['thermodynamic_state']

                # Check if the standard state is in a previous state.
                try:
                    standard_system_name = serialized_thermodynamic_state.pop('_Reporter__compatible_state')
                except KeyError:
                    # We have stored the full standard system serialization.
                    pass
                else:
                    # The system serialization can be retrieved from another state.
                    reference_state_type, reference_system_id = standard_system_name.split('/')
                    compatible_thermodynamic_state = states[reference_state_type][int(reference_system_id)]
                    serialized_system = openmm.XmlSerializer.serialize(compatible_thermodynamic_state.system)
                    serialized_thermodynamic_state['standard_system'] = serialized_system

                # Create ThermodynamicState object.
                states[state_type].append(mmtools.utils.deserialize(serialized_state))
                state_id += 1

        return [states['thermodynamic_states'], states['unsampled_states']]

    @mmtools.utils.with_timer('Storing thermodynamic states')
    def write_thermodynamic_states(self, thermodynamic_states, unsampled_states):
        """Store all the ThermodynamicStates.

        Parameters
        ----------
        thermodynamic_states : list of ThermodynamicState
            The thermodynamic states to store.
        unsampled_states : list of ThermodynamicState
            The unsampled thermodynamic states to store.

        See Also
        --------
        write_replica_thermodynamic_states

        """
        self._check_version_compatibility()

        # Store all thermodynamic states as serialized dictionaries.
        compatible_states_hashes = dict()
        for state_type, states in [('thermodynamic_states', thermodynamic_states),
                                  ('unsampled_states', unsampled_states)]:
            for state_id, thermodynamic_state in enumerate(states):
                serialized_state = mmtools.utils.serialize(thermodynamic_state)

                # Find the serialized standard system.
                serialized_thermodynamic_state = serialized_state
                while 'thermodynamic_state' in serialized_thermodynamic_state:
                    # The while loop is necessary for nested CompoundThermodynamicStates.
                    serialized_thermodynamic_state = serialized_state['thermodynamic_state']
                serialized_standard_system = serialized_thermodynamic_state['standard_system']

                # We store the full standard system serialization only if we haven't
                # store it yet, otherwise we just write a reference to a state containing
                # the full system. We normally expect all the ThermodynamicStates to be
                # compatible, which means we'll store only a single system in most cases.
                standard_system_hash = serialized_standard_system.__hash__()
                try:
                    reference_state_name, len_serialization = compatible_states_hashes[standard_system_hash]
                except KeyError:
                    reference_state_name = '{}/{}'.format(state_type, state_id)
                    len_serialization = len(serialized_standard_system)
                    compatible_states_hashes[standard_system_hash] = reference_state_name, len_serialization

                    logger.debug("Serialized state {} is  {}B | {:.3f}KB | {:.3f}MB".format(
                        reference_state_name, len_serialization, len_serialization/1024.0,
                        len_serialization/1024.0/1024.0))
                else:
                    serialized_thermodynamic_state.pop('standard_system')
                    serialized_thermodynamic_state['_Reporter__compatible_state'] = reference_state_name

                # Write state as dictionary.
                self.write_dict('{}/state{}'.format(state_type, state_id), serialized_state)

    def read_sampler_states(self, iteration):
        """Retrieve the stored sampler states.

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        Returns
        -------
        sampler_states : list of SamplerStates
            The previously stored sampler states for each replica.

        """
        n_states = self._storage.dimensions['replica'].size

        sampler_states = list()
        for replica_index in range(n_states):
            # Restore positions.
            x = self._storage.variables['positions'][iteration, replica_index, :, :].astype(np.float64)
            positions = unit.Quantity(x, unit.nanometers)

            # Restore box vectors.
            x = self._storage.variables['box_vectors'][iteration, replica_index, :, :].astype(np.float64)
            box_vectors = unit.Quantity(x, unit.nanometers)

            # Create SamplerState.
            sampler_states.append(mmtools.states.SamplerState(positions=positions, box_vectors=box_vectors))

        return sampler_states

    @mmtools.utils.with_timer('Storing sampler states')
    def write_sampler_states(self, sampler_states, iteration):
        """Store all sampler states for a given iteration.

        Parameters
        ----------
        sampler_states : list of SamplerStates
            The sampler states to store for each replica.
        iteration : int
            The iteration at which to store the data.

        """
        self._check_version_compatibility()

        # Check if the schema must be initialized.
        if 'positions' not in self._storage.variables:
            n_atoms = sampler_states[0].n_particles
            n_states = len(sampler_states)

            # Create dimensions. Replica dimension could have been created before.
            self._storage.createDimension('atom', n_atoms)
            if 'replica' not in self._storage.dimensions:
                self._storage.createDimension('replica', n_states)

            # Create variables.
            ncvar_positions = self._storage.createVariable('positions', 'f4',
                                                           ('iteration', 'replica', 'atom', 'spatial'),
                                                           zlib=True, chunksizes=(1, n_states, n_atoms, 3))
            ncvar_box_vectors = self._storage.createVariable('box_vectors', 'f4',
                                                             ('iteration', 'replica', 'spatial', 'spatial'),
                                                             zlib=False, chunksizes=(1, n_states, 3, 3))
            ncvar_volumes = self._storage.createVariable('volumes', 'f8', ('iteration', 'replica'),
                                                         zlib=False, chunksizes=(1, n_states))

            # Define units for variables.
            setattr(ncvar_positions, 'units', 'nm')
            setattr(ncvar_box_vectors, 'units', 'nm')
            setattr(ncvar_volumes, 'units', 'nm**3')

            # Define long (human-readable) names for variables.
            setattr(ncvar_positions, "long_name", ("positions[iteration][replica][atom][spatial] is position of "
                                                   "coordinate 'spatial' of atom 'atom' from replica 'replica' for "
                                                   "iteration 'iteration'."))

            setattr(ncvar_box_vectors, "long_name", ("box_vectors[iteration][replica][i][j] is dimension j of box "
                                                     "vector i for replica 'replica' from iteration 'iteration-1'."))
            setattr(ncvar_volumes, "long_name", ("volume[iteration][replica] is the box volume for replica 'replica' "
                                                 "from iteration 'iteration-1'."))

        # Store sampler states.
        for replica_index, sampler_state in enumerate(sampler_states):
            # Store positions
            x = sampler_state.positions / unit.nanometers
            self._storage.variables['positions'][iteration, replica_index, :, :] = x[:, :]

            # Store box vectors and volume.
            for i in range(3):
                vector_i = sampler_state.box_vectors[i] / unit.nanometers
                self._storage.variables['box_vectors'][iteration, replica_index, i, :] = vector_i
            self._storage.variables['volumes'][iteration, replica_index] = sampler_state.volume / unit.nanometers**3

    def read_replica_thermodynamic_states(self, iteration):
        """Retrieve the indices of the ThermodynamicStates for each replica.

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        Returns
        -------
        state_indices : list of int
            At the given iteration, replica i propagated the system in
            SamplerState sampler_states[i] and ThermodynamicState
            thermodynamic_states[states_indices[i]].

        """
        return self._storage.variables['states'][iteration].astype(np.int64)

    def write_replica_thermodynamic_states(self, state_indices, iteration):
        """Store the indices of the ThermodynamicStates for each replica.

        Parameters
        ----------
        state_indices : list of int
            At the given iteration, replica i propagated the system in
            SamplerState sampler_states[i] and ThermodynamicState
            thermodynamic_states[replica_thermodynamic_states[i]].
        iteration : int
            The iteration at which to store the data.

        """
        self._check_version_compatibility()

        # Initialize schema if needed.
        if 'states' not in self._storage.variables:
            n_states = len(state_indices)

            # Create dimension if they don't exist.
            if 'replica' not in self._storage.dimensions:
                self._storage.createDimension('replica', n_states)

            # Create variables and attach units and description.
            ncvar_states = self._storage.createVariable('states', 'i4', ('iteration', 'replica'),
                                                        zlib=False, chunksizes=(1, n_states))
            setattr(ncvar_states, 'units', 'none')
            setattr(ncvar_states, "long_name", ("states[iteration][replica] is the thermodynamic state index "
                                                "(0..nstates-1) of replica 'replica' of iteration 'iteration'."))

        # Store thermodynamic states indices.
        self._storage.variables['states'][iteration, :] = state_indices[:]

    def read_mcmc_moves(self):
        """Return the MCMCMoves of the ReplicaExchange simulation.

        Returns
        -------
        mcmc_moves : list of MCMCMove
            The MCMCMoves used to propagate the simulation.

        """
        # Handle previous convention versions.
        convention_version = StrictVersion(getattr(self._storage, 'ConventionVersion'))
        if convention_version <= StrictVersion('0.1'):
            # With 0.1, only LangevinIntegration was possible.
            move = mmtools.mcmc.LangevinDynamicsMove(timestep=2.0*unit.femtosecond,
                                                     collision_rate=5.0/unit.picosecond,
                                                     n_steps=500, reassign_velocities=True,
                                                     n_restart_attempts=6)
            return [copy.deepcopy(move) for _ in range(self._storage.dimensions['replica'].size)]

        # Get group storing MCMCMoves.
        ncgrp = self._storage.groups['mcmc_moves']

        # Retrieve all moves in order.
        mcmc_moves = list()
        for i in range(len(ncgrp.groups)):
            serialized_move = self._read_dict(ncgrp.groups['move' + str(i)])
            mcmc_moves.append(mmtools.utils.deserialize(serialized_move))
        return mcmc_moves

    def write_mcmc_moves(self, mcmc_moves):
        """Store the MCMCMoves of the ReplicaExchange simulation.

        Parameters
        ----------
        mcmc_moves : list of MCMCMove
            The MCMCMoves used to propagate the simulation.

        """
        self._check_version_compatibility()

        # Serialize and store MCMCMoves.
        for i, mcmc_move in enumerate(mcmc_moves):
            serialized_move = mmtools.utils.serialize(mcmc_move)
            self.write_dict('mcmc_moves/move' + str(i), serialized_move)

    def read_energies(self, iteration):
        """Retrieve the energy matrix at the given iteration.

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        Returns
        -------
        energy_thermodynamic_states : n_replicas x n_replicas numpy.ndarray
            energy_thermodynamic_states[i][j] is the reduced potential computed at
            SamplerState sampler_states[i] and ThermodynamicState thermodynamic_states[j].
        energy_unsampled_states : n_replicas x n_unsampled_states numpy.ndarray
            energy_unsampled_states[i][j] is the reduced potential computed at SamplerState
            sampler_states[i] and ThermodynamicState unsampled_thermodynamic_states[j].

        """
        # Handle previous versions of the conventions.
        convention_version = StrictVersion(getattr(self._storage, 'ConventionVersion'))
        if convention_version == StrictVersion('0.1'):
            return self._read_energies_0_1(iteration)

        energy_thermodynamic_states = self._storage.variables['energies'][iteration, :, :]
        try:
            energy_unsampled_states = self._storage.variables['unsampled_energies'][iteration, :, :]
        except KeyError:
            # There are no unsampled thermodynamic states.
            energy_unsampled_states = np.zeros((len(energy_thermodynamic_states), 0))
        return energy_thermodynamic_states, energy_unsampled_states

    def write_energies(self, energy_thermodynamic_states, energy_unsampled_states, iteration):
        """Store the energy matrix at the given iteration.

        Parameters
        ----------
        energy_thermodynamic_states : n_replicas x n_replicas numpy.ndarray
            energy_thermodynamic_states[i][j] is the reduced potential computed at
            SamplerState sampler_states[i] and ThermodynamicState thermodynamic_states[j].
        energy_unsampled_states : n_replicas x n_unsampled_states numpy.ndarray
            energy_unsampled_states[i][j] is the reduced potential computed at SamplerState
            sampler_states[i] and ThermodynamicState unsampled_thermodynamic_states[j].
        iteration : int
            The iteration at which to store the data.

        """
        self._check_version_compatibility()

        # Initialize schema if needed.
        if 'energies' not in self._storage.variables:
            n_replicas = len(energy_thermodynamic_states)

            # Create replica dimension if it wasn't created by other functions.
            if 'replica' not in self._storage.dimensions:
                self._storage.createDimension('replica', n_replicas)

            # Create variable for thermodynamic state energies with units and descriptions.
            ncvar_energies = self._storage.createVariable('energies', 'f8', ('iteration', 'replica', 'replica'),
                                                          zlib=False, chunksizes=(1, n_replicas, n_replicas))
            ncvar_energies.units = 'kT'
            ncvar_energies.long_name = ("energies[iteration][replica][state] is the reduced (unitless) "
                                        "energy of replica 'replica' from iteration 'iteration' evaluated "
                                        "at the thermodynamic state 'state'.")

            # Check if we have unsampled states.
            if energy_unsampled_states.shape[1] > 0:
                if 'unsampled_energies' not in self._storage.variables:
                    n_unsampled_states = len(energy_unsampled_states[0])

                    # Create replica dimension if it wasn't created by other functions.
                    if 'unsampled' not in self._storage.dimensions:
                        self._storage.createDimension('unsampled', n_unsampled_states)

                    # Create variable for thermodynamic state energies with units and descriptions.
                    ncvar_unsampled = self._storage.createVariable('unsampled_energies', 'f8',
                                                                   ('iteration', 'replica', 'unsampled'), zlib=False,
                                                                   chunksizes=(1, n_replicas, n_unsampled_states))
                    ncvar_unsampled.units = 'kT'
                    ncvar_unsampled.long_name = ("unsampled_energies[iteration][replica][state] is the reduced "
                                                 "(unitless) energy of replica 'replica' from iteration 'iteration' "
                                                 "evaluated at unsampled thermodynamic state 'state'.")

        # Store states energy.
        self._storage.variables['energies'][iteration, :, :] = energy_thermodynamic_states[:, :]
        if energy_unsampled_states.shape[1] > 0:
            self._storage.variables['unsampled_energies'][iteration, :, :] = energy_unsampled_states[:, :]

    def read_mixing_statistics(self, iteration):
        """Retrieve the mixing statistics for the given iteration.

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        Returns
        -------
        n_accepted_matrix : kxk numpy.ndarray
            n_accepted_matrix[i][j] is the number of accepted moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).
        n_proposed_matrix : kxk numpy.ndarray
            n_proposed_matrix[i][j] is the number of proposed moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).

        """
        n_accepted_matrix = self._storage.variables['accepted'][iteration, :, :].astype(np.int64)
        n_proposed_matrix = self._storage.variables['proposed'][iteration, :, :].astype(np.int64)
        return n_accepted_matrix, n_proposed_matrix

    def write_mixing_statistics(self, n_accepted_matrix, n_proposed_matrix, iteration):
        """Store the mixing statistics for the given iteration.

        Parameters
        ----------
        n_accepted_matrix : kxk numpy.ndarray
            n_accepted_matrix[i][j] is the number of accepted moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).
        n_proposed_matrix : kxk numpy.ndarray
            n_proposed_matrix[i][j] is the number of proposed moves from
            state thermodynamic_states[i] to thermodynamic_states[j] going
            from iteration-1 to iteration (not cumulative).
        iteration : int
            The iteration at which to store the data.

        """
        self._check_version_compatibility()

        # Create schema if necessary.
        if 'accepted' not in self._storage.variables:
            n_states = len(n_accepted_matrix)

            # Create replica dimension if it wasn't already created.
            if 'replica' not in self._storage.dimensions:
                self._storage.createDimension('replica', n_states)

            # Create variables with units and descriptions.
            ncvar_accepted = self._storage.createVariable('accepted', 'i4', ('iteration', 'replica', 'replica'),
                                                          zlib=False, chunksizes=(1, n_states, n_states))
            ncvar_proposed = self._storage.createVariable('proposed', 'i4', ('iteration', 'replica', 'replica'),
                                                          zlib=False, chunksizes=(1, n_states, n_states))
            setattr(ncvar_accepted, 'units', 'none')
            setattr(ncvar_proposed, 'units', 'none')
            setattr(ncvar_accepted, 'long_name', ("accepted[iteration][i][j] is the number of proposed transitions "
                                                  "between states i and j from iteration 'iteration-1'."))
            setattr(ncvar_proposed, 'long_name', ("proposed[iteration][i][j] is the number of proposed transitions "
                                                  "between states i and j from iteration 'iteration-1'."))

        # Store statistics.
        self._storage.variables['accepted'][iteration, :, :] = n_accepted_matrix[:, :]
        self._storage.variables['proposed'][iteration, :, :] = n_proposed_matrix[:, :]

    def read_timestamp(self, iteration):
        """Return the timestamp for the given iteration.

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        Returns
        -------
        timestamp : str
            The timestamp at which the iteration was stored.

        """
        return self._storage.variables['timestamp'][iteration]

    def write_timestamp(self, iteration):
        """Store a timestamp for the given iteration.

        Parameters
        ----------
        iteration : int
            The iteration at which to read the data.

        """
        self._check_version_compatibility()

        # Create variable if needed.
        if 'timestamp' not in self._storage.variables:
            self._storage.createVariable('timestamp', str, ('iteration',), zlib=False, chunksizes=(1,))
        self._storage.variables['timestamp'][iteration] = time.ctime()

    def read_dict(self, name):
        """Restore a dictionary from the storage file.

        Parameters
        ----------
        name : str
            The identifier of the dictionary used to stored the data.

        Returns
        -------
        data : dict
            The restored data as a dict.

        """
        ncgrp = self._storage.groups[name]
        data = self._read_dict(ncgrp)

        # Restore the title in the metadata.
        if name == 'metadata':
            data['title'] = self._storage.title
        return data

    def write_dict(self, name, data):
        """Store the contents of a dict.

        Parameters
        ----------
        name : str
            The identifier of the dictionary in the storage file.
        data : dict
            The dict to store.

        """
        self._check_version_compatibility()

        # General NetCDF conventions assume the title of the dataset to be
        # specified as a global attribute, but the user can specify their
        # own titles only in metadata.
        if name == 'metadata':
            data = copy.deepcopy(data)
            self._storage.title = data.pop('title')

        # Check if this is an update and create a group.
        # TODO: this is a quick and dirty solution for dictionary updates that
        # TODO:     will be fixed with the storage layer.
        try:
            # This may be a nested dictionary call.
            split_path = name.rsplit('/')
            ncgrp = self._storage
            for group_name in split_path:
                ncgrp = ncgrp.groups[group_name]
            is_update = True
        except KeyError:
            ncgrp = self._storage.createGroup(name)
            is_update = False

        for key, value in data.items():
            # If Quantity, strip off units first.
            value_unit = None
            if isinstance(value, unit.Quantity):
                value_unit = value.unit
                value = value / value_unit

            # Check the Python type.
            value_type = type(value)
            stored_type_name = utils.typename(value_type)

            # We store booleans as integers.
            if isinstance(value, bool):
                # Keep stored_type_name as bool to store original type.
                value = int(value)
                value_type = int

            # Store the variable.
            if isinstance(value, dict):
                # Nested dictionary in a subgroup.
                self.write_dict(name + '/' + key, value)
                # No need to store ncvar type as this will be marked as group.
                ncvar = None
            elif isinstance(value, str):
                if is_update:
                    ncvar = ncgrp.variables[key]
                else:
                    ncvar = ncgrp.createVariable(key, value_type, 'scalar')
                packed_data = np.empty(1, 'O')
                packed_data[0] = value
                ncvar[:] = packed_data
            elif isinstance(value, collections.Iterable):
                if is_update:
                    ncvar = ncgrp.variables[key]
                else:
                    # Cast as numpy array to check shape and extract the element
                    # type. np.ravel() returns a view, it doesn't allocate memory.
                    value = np.array(value)
                    element_type = type(value.ravel()[0])
                    element_type_name = utils.typename(element_type)

                    # Create dimensions and variable.
                    dimensions_names = tuple([key + 'dimension' + str(i) for i in range(len(value.shape))])
                    for dimension_name, dimension in zip(dimensions_names, value.shape):
                        ncgrp.createDimension(dimension_name, dimension)
                    ncvar = ncgrp.createVariable(key, element_type, dimensions_names)

                    # Store element type instead of array type.
                    stored_type_name = element_type_name
                ncvar[:] = value[:]
            elif value is None:
                if is_update:
                    ncvar = ncgrp.variables[key]
                else:
                    ncvar = ncgrp.createVariable(key, int)
                ncvar.assignValue(0)
            else:
                if is_update:
                    ncvar = ncgrp.variables[key]
                else:
                    ncvar = ncgrp.createVariable(key, value_type)
                ncvar.assignValue(value)

            # Set the type of the variable if this wasn't a dictionary.
            if ncvar is not None:
                setattr(ncvar, 'type', stored_type_name)

            # Log value (truncate if too long but save length)
            if hasattr(value, '__len__'):
                logger.debug("Storing option: {} -> {} (type: {}, length {})".format(
                    key, str(value)[:100], stored_type_name, len(value)))
            else:
                logger.debug("Storing option: {} -> {} (type: {})".format(
                    key, value, stored_type_name))
            if value_unit is not None:
                setattr(ncvar, 'units', str(value_unit))

    # -------------------------------------------------------------------------
    # Internal-usage
    # -------------------------------------------------------------------------

    def _read_dict(self, ncgrp):
        """Read and return a dictionary.

        Takes a group instead of a name to resolve nested dictionaries.

        """
        data = dict()

        # Restore nested dictionaries.
        for name, nested_ncgrp in ncgrp.groups.items():
            data[name] = self._read_dict(nested_ncgrp)

        # Restore variables.
        for key, ncvar in ncgrp.variables.items():
            type_name = getattr(ncvar, 'type')
            # TODO: Remove the if/elseif structure into one handy function
            # Get option value.
            if type_name == 'NoneType':
                value = None
            else:  # Handle all Types not None
                value_type = self._convert_netcdf_store_type(type_name)
                if ncvar.shape == ():  # Standard Types
                    value = value_type(ncvar.getValue())
                elif ncvar.shape[0] >= 0:  # Array types
                    value = np.array(ncvar[:], value_type)
                    if issubclass(value_type, str):
                        value = value_type(value[0])
                else:
                    raise ValueError('Cannot restore type {} with value {}'.format(
                        value_type, ncvar.getValue()))

            # If Quantity, assign unit.
            if hasattr(ncvar, 'units'):
                value_unit_name = getattr(ncvar, 'units')
                if value_unit_name[0] == '/':
                    value_unit = utils.quantity_from_string(value_unit_name[1:])
                    value = value / value_unit
                else:
                    value_unit = utils.quantity_from_string(value_unit_name)
                    value = value * value_unit

            # Log value (truncate if too long but save length)
            if hasattr(value, '__len__'):
                try:
                    value_len = len(value)
                except TypeError:  # this is a zero-dimensional array
                    value_len = np.atleast_1d(value)
                logger.debug("Restoring option: {} -> {} (type: {}, length {})".format(
                    key, str(value)[:500], type(value), value_len))
            else:
                logger.debug("Restoring option: {} -> {} (type: {})".format(
                    key, value, type(value)))

            # Store option.
            data[key] = value

        return data

    @staticmethod
    def _convert_netcdf_store_type(stored_type):
        """
        Convert the stored NetCDF datatype from string to type without relying on unsafe eval() function

        Parameters
        ----------
        stored_type : string
            Read from ncfile.Variable.type stored by repex

        Returns
        -------
        proper_type : type
            Python or module type

        """
        try:
            # Check if it's a builtin type
            try:  # Python 2
                module = importlib.import_module('__builtin__')
            except:  # Python 3
                module = importlib.import_module('builtins')
            proper_type = getattr(module, stored_type)
        except AttributeError:
            # if not, separate module and class
            module, stored_type = stored_type.rsplit(".", 1)
            module = importlib.import_module(module)
            proper_type = getattr(module, stored_type)
        return proper_type

    # -------------------------------------------------------------------------
    # Internal-usage: Backward compatibility.
    # -------------------------------------------------------------------------

    _LATEST_CONVENTION_VERSION = StrictVersion('0.2')

    # Dict storage_conventions: last_compatible_YANK_version.
    _LAST_COMPATIBLE_YANK_VERSIONS = {'0.1': '0.15.2'}

    def _check_version_compatibility(self):
        """Raise an error if storage conventions are not supported.

        We generally support reading so that analysis on old datasets will still
        be available with a recent version of Yank, but we don't support writing
        new data in an old format.

        """
        # Raise an error if ConventionVersion is not the latest.
        convention_version = StrictVersion(getattr(self._storage, 'ConventionVersion'))
        if convention_version != self._LATEST_CONVENTION_VERSION:
            yank_version = self._LAST_COMPATIBLE_YANK_VERSIONS[str(convention_version)]
            raise RuntimeError('These storage conventions are deprecated. Reading data is'
                               ' still supported for analysis, but writing could corrupt'
                               ' the dataset. The last version of the program supporting '
                               'writing for these conventions is {}'.format(yank_version))

    def _read_thermodynamic_states_0_1(self):
        """Retrieve the stored thermodynamic states with conventions 0.1."""
        try:
            return self._read_thermodynamic_states_rex_0_1()
        except KeyError:
            return self._read_thermodynamic_states_mhex_0_1()

    def _read_thermodynamic_states_rex_0_1(self):
        """Retrieve the stored thermodynamic states with conventions 0.1.

        This is for the conventions used in ReplicaExchange.

        """
        logger.debug('Attempt to read thermodynamic states with ReplicaExchange reader version 0.1.')

        ncgrp_states = self._storage.groups['thermodynamic_states']
        n_states = self._storage.dimensions['replica'].size
        thermodynamic_states = list()
        for state_index in range(n_states):
            # Reconstitute System object.
            system = openmm.System()
            system.__setstate__(ncgrp_states.variables['systems'][state_index])
            # Read temperature and pressure (if NPT).
            temperature = ncgrp_states.variables['temperatures'][state_index] * unit.kelvin
            if 'pressures' in ncgrp_states.variables:
                pressure = ncgrp_states.variables['pressures'][state_index] * unit.atmospheres
            else:
                pressure = None
            # Create ThermodynamicState.
            thermodynamic_states.append(ThermodynamicState(system=system, temperature=temperature,
                                                           pressure=pressure))
        return thermodynamic_states, []

    def _read_thermodynamic_states_mhex_0_1(self):
        """Retrieve the stored thermodynamic states with conventions 0.1.

        This is for the conventions used in ModifiedHamiltonianExchange.

        """
        logger.debug('Attempt to read thermodynamic states with '
                     'ModifiedHamiltonianExchange reader version 0.1.')

        ncgrp_states = self._storage.groups['thermodynamic_states']
        ncgrp_alchemical = self._storage.groups['alchemical_states']
        # Read reference system
        base_system = openmm.System()
        base_system.__setstate__(str(ncgrp_states.variables['base_system'][0]))
        # Read other parameters.
        thermodynamic_states = list()
        n_states = self._storage.dimensions['replica'].size
        for state_index in range(n_states):
            # Create thermodynamic state.
            temperature = float(ncgrp_states.variables['temperatures'][state_index]) * unit.kelvin
            if 'pressures' in ncgrp_states.variables:
                pressure = float(ncgrp_states.variables['pressures'][state_index]) * unit.atmosphere
            else:
                pressure = None
            thermodynamic_state = ThermodynamicState(base_system, temperature, pressure)
            # Create alchemical state.
            alchemical_state = mmtools.alchemy.AlchemicalState.from_system(base_system)
            for parameter_name, ncvar_parameter in ncgrp_alchemical.variables.items():
                if getattr(alchemical_state, parameter_name) is not None:
                    parameter_value = float(ncvar_parameter[state_index])
                    setattr(alchemical_state, parameter_name, parameter_value)
            # Create compound state.
            thermodynamic_states.append(mmtools.states.CompoundThermodynamicState(thermodynamic_state,
                                                                                  [alchemical_state]))

        unsampled_states = list()
        if 'expanded_cutoff_states' in self._storage.groups:
            ncgrp_expanded = self._storage.groups['expanded_cutoff_states']
            temperature = float(ncgrp_expanded.variables['temperatures'][0]) * unit.kelvin
            try:
                pressure = float(ncgrp_expanded.variables['pressures'][0]) * unit.atmosphere
            except KeyError:
                pressure = None
            for variable_name in ['fully_interacting_expanded_system', 'noninteracting_expanded_system']:
                ncvar_serialized_system = ncgrp_expanded.variables[variable_name]
                expanded_system = openmm.System()
                expanded_system.__setstate__(str(ncvar_serialized_system[0]))
                unsampled_states.append(ThermodynamicState(expanded_system, temperature, pressure))

        return thermodynamic_states, unsampled_states

    def _read_energies_0_1(self, iteration):
        """Retrieve the energy matrices with conventions 0.1."""
        energy_thermodynamic_states = self._storage.variables['energies'][iteration]
        if 'noninteracting_expanded_cutoff_energies' in self._storage.variables:
            u_k_full = self._storage.variables['fully_interacting_expanded_cutoff_energies'][iteration]
            u_k_non = self._storage.variables['noninteracting_expanded_cutoff_energies'][iteration]
            energy_unsampled_states = np.array([u_k_full, u_k_non]).T
        else:
            energy_unsampled_states = np.zeros((len(energy_thermodynamic_states), 0))
        return energy_thermodynamic_states, energy_unsampled_states


# ==============================================================================
# REPLICA-EXCHANGE SIMULATION
# ==============================================================================

class ReplicaExchange(object):
    """Replica-exchange simulation facility.

    This base class provides a general replica-exchange simulation facility,
    allowing any set of thermodynamic states to be specified, along with a
    set of initial positions to be assigned to the replicas in a round-robin
    fashion.

    No distinction is made between one-dimensional and multidimensional replica
    layout. By default, the replica mixing scheme attempts to mix *all* replicas
    to minimize slow diffusion normally found in multidimensional replica exchange
    simulations (Modification of the 'replica_mixing_scheme' setting will allow
    the traditional 'neighbor swaps only' scheme to be used.)

    Stored configurations, energies, swaps, and restart information are all written
    to a single output file using the platform portable, robust, and efficient
    NetCDF4 library.

    Parameters
    ----------
    mcmc_moves : MCMCMove or list of MCMCMove, optional
        The MCMCMove used to propagate the states. If a list of MCMCMoves,
        they will be assigned to the correspondent thermodynamic state on
        creation. If None is provided, Langevin dynamics with 2fm timestep,
        5.0/ps collision rate, and 500 steps per iteration will be used.
    number_of_iterations : int, optional
        The number of iterations to perform (default is 1).
    replica_mixing_scheme : 'swap-all', 'swap-neighbors' or 'none'
        The scheme used to swap thermodynamic states between replicas
        (default is 'swap-all').
    online_analysis : bool, optional
        If True, analysis will occur each iteration (default is False).
    online_analysis_min_iterations : int, optional
        Minimum number of iterations needed to begin online analysis
        (default is 20).
    show_energies : bool, optional
       If True, will print energies at each iteration (default is True).
    show_mixing_statistics : bool, optional
       If True, will show mixing statistics at each iteration (default is True).

    Attributes
    ----------
    mcmc_moves
    number_of_iterations
    replica_mixing_scheme
    online_analysis
    online_analysis_min_iterations
    show_energies
    show_mixing_statistics

    Examples
    --------
    Parallel tempering simulation of alanine dipeptide in implicit solvent (replica
    exchange among temperatures). This is just an illustrative example; use ParallelTempering
    class for actual production parallel tempering simulations.

    Create the system.

    >>> import math
    >>> from simtk import unit
    >>> from openmmtools import testsystems, states, mcmc
    >>> testsystem = testsystems.AlanineDipeptideImplicit()

    Create thermodynamic states for parallel tempering with exponentially-spaced schedule.

    >>> n_replicas = 3  # Number of temperature replicas.
    >>> T_min = 298.0 * unit.kelvin  # Minimum temperature.
    >>> T_max = 600.0 * unit.kelvin  # Maximum temperature.
    >>> temperatures = [T_min + (T_max - T_min) * (math.exp(float(i) / float(nreplicas-1)) - 1.0) / (math.e - 1.0)
    ...                 for i in range(n_replicas)]
    >>> thermodynamic_states = [states.ThermodynamicState(system=testsystem.system, temperature=T)
    ...                         for T in temperatures]

    Initialize simulation object with options. Run with a GHMC integrator.

    >>> move = mcmc.GHMCMove(timestep=2.0*unit.femtoseconds, n_steps=50)
    >>> simulation = ReplicaExchange(mcmc_moves=move, number_of_iterations=2)

    Create simulation with its storage file (in a temporary directory) and run.

    >>> storage_path = tempfile.NamedTemporaryFile(delete=False).name + '.nc'
    >>> simulation.create(thermodynamic_states=thermodynamic_states,
    >>>                   sampler_states=states.SamplerState(testsystem.positions),
    >>>                   storage=storage_path)
    >>> simulation.run()  # This runs for a maximum of 2 iterations.
    >>> simulation.iteration
    2
    >>> simulation.run(n_iterations=1)
    >>> simulation.iteration
    2

    To resume a simulation from an existing storage file and extend it beyond
    the original number of iterations.

    >>> del simulation
    >>> simulation = ReplicaExchange.from_storage(storage_path)
    >>> simulation.extend(n_iterations=1)
    >>> simulation.iteration
    3

    You can extract several information from the NetCDF file using the Reporter
    class while the simulation is running. This reads the SamplerStates of every
    run iteration.

    >>> reporter = Reporter(storage=storage_path, open_mode='r')
    >>> sampler_states = reporter.read_sampler_states(iteration=range(1, 4))
    >>> len(sampler_states)
    3
    >>> sampler_states[-1].positions.shape  # Alanine dipeptide has 22 atoms.
    (22, 3)

    Clean up.

    >>> os.remove(storage_path)

    """

    # -------------------------------------------------------------------------
    # Constructors.
    # -------------------------------------------------------------------------

    def __init__(self, mcmc_moves=None,
                 number_of_iterations=1,
                 replica_mixing_scheme='swap-all',
                 online_analysis=False,
                 online_analysis_min_iterations=20,
                 show_energies=True,
                 show_mixing_statistics=True):

        # Check argument values.
        if replica_mixing_scheme not in self._SUPPORTED_MIXING_SCHEMES:
            raise ValueError("Unknown replica mixing scheme '{}'. Supported values are {}.".format(
                replica_mixing_scheme, self._SUPPORTED_MIXING_SCHEMES))

        # Handling default propagator.
        if mcmc_moves is None:
            # This will be converted to a list in create().
            self._mcmc_moves = mmtools.mcmc.LangevinDynamicsMove(timestep=2.0*unit.femtosecond,
                                                                 collision_rate=5.0/unit.picosecond,
                                                                 n_steps=500, reassign_velocities=True,
                                                                 n_restart_attempts=6)
        else:
            self._mcmc_moves = copy.deepcopy(mcmc_moves)

        # Store constructor parameters. Everything is marked for internal
        # usage because any change to these attribute would imply a change
        # in the storage file as well, which we don't currently support.
        self._number_of_iterations = number_of_iterations
        self._replica_mixing_scheme = replica_mixing_scheme
        self._online_analysis = online_analysis
        self._online_analysis_min_iterations = online_analysis_min_iterations
        self._show_energies = show_energies
        self._show_mixing_statistics = show_mixing_statistics

        # These will be set on initialization. See function
        # create() for explanation of single variables.
        self._thermodynamic_states = None
        self._unsampled_states = None
        self._sampler_states = None
        self._replica_thermodynamic_states = None
        self._iteration = None
        self._energy_thermodynamic_states = None
        self._energy_unsampled_states = None
        self._n_accepted_matrix = None
        self._n_proposed_matrix = None
        self._reporter = None

    @classmethod
    def from_storage(cls, storage):
        """Constructor from an existing storage file.

        Parameters
        ----------
        storage : str
            The path to the storage file. In the future this will be able
            to take a Reporter or a Storage class as well.

        Returns
        -------
        repex : ReplicaExchange
            A new instance of ReplicaExchange in the same state of the
            last stored iteration.

        """
        # Check if netcdf file exists.
        file_exists = cls._does_file_exist(storage)
        if not file_exists:
            raise RuntimeError('Storage file {} does not exists; cannot resume.'.format(storage))

        # Open a reporter to read the data.
        reporter = Reporter(storage, open_mode='r')

        # Retrieve options and create new simulation.
        options = reporter.read_dict('options')
        options['mcmc_moves'] = reporter.read_mcmc_moves()
        repex = ReplicaExchange(**options)

        # Display papers to be cited.
        repex._display_citations()

        # Count timestamps to retrieve the current number of iterations.
        # Timestamp is the last thing reported in _report_iteration, so
        # we are sure that the full iteration information has been stored
        # and the simulation has not been interrupted during the report.
        iteration = len(reporter.read_timestamp(iteration=slice(None))) - 1  # 0-based

        # Retrieve other attributes.
        logger.debug("Reading storage file {}...".format(storage))
        thermodynamic_states, unsampled_states = reporter.read_thermodynamic_states()
        sampler_states = reporter.read_sampler_states(iteration=iteration)
        state_indices = reporter.read_replica_thermodynamic_states(iteration=iteration)
        energy_thermodynamic_states, energy_unsampled_states = reporter.read_energies(iteration=iteration)
        n_accepted_matrix, n_proposed_matrix = reporter.read_mixing_statistics(iteration=iteration)

        # Close reading reporter.
        reporter.close()

        # Assign attributes.
        repex._iteration = iteration
        repex._thermodynamic_states = thermodynamic_states
        repex._unsampled_states = unsampled_states
        repex._sampler_states = sampler_states
        repex._replica_thermodynamic_states = state_indices
        repex._energy_thermodynamic_states = energy_thermodynamic_states
        repex._energy_unsampled_states = energy_unsampled_states
        repex._n_accepted_matrix = n_accepted_matrix
        repex._n_proposed_matrix = n_proposed_matrix

        # We open the reporter only in node 0.
        repex._reporter = Reporter(storage, open_mode=None)
        mpi.run_single_node(0, repex._reporter.open, mode='a',
                            broadcast_result=False, sync_nodes=False)
        return repex

    # -------------------------------------------------------------------------
    # Public properties.
    # -------------------------------------------------------------------------

    @property
    def n_replicas(self):
        """The number of replicas (read-only)."""
        if self._thermodynamic_states is None:
            return 0
        else:
            return len(self._thermodynamic_states)

    @property
    def iteration(self):
        """The current iteration of the simulation (read-only).

        If the simulation has not been created yet, this is None.

        """
        return self._iteration

    @property
    def mcmc_moves(self):
        """A copy of the MCMCMoves used to propagate the simulation.

        This can be set only before creation.

        """
        return copy.deepcopy(self._mcmc_moves)

    @mcmc_moves.setter
    def mcmc_moves(self, new_value):
        if self._thermodynamic_states is not None:
            # We can't modify representation of the MCMCMoves because it's
            # impossible to delete groups/variables from an NetCDF file. We
            # could support this by JSONizing the dict serialization and
            # store it as a string instead, if we needed this.
            raise RuntimeError('Cannot modify MCMCMoves after creation.')
        # If this is a single MCMCMove, it'll be transformed to a list in create().
        self._mcmc_moves = copy.deepcopy(new_value)

    class _StoredProperty(object):
        """Descriptor of a property stored as an option."""
        def __init__(self, option_name):
            self._option_name = option_name

        def __get__(self, instance, owner_class=None):
            return getattr(instance, '_' + self._option_name)

        def __set__(self, instance, new_value):
            if (self._option_name == 'replica_mixing_scheme' and
                        new_value not in ReplicaExchange._SUPPORTED_MIXING_SCHEMES):
                raise ValueError(("Unknown replica mixing scheme '{}'. Supported values "
                                  "are {}.").format(new_value, self._SUPPORTED_MIXING_SCHEMES))
            setattr(instance, '_' + self._option_name, new_value)
            mpi.run_single_node(0, instance._store_options)

    number_of_iterations = _StoredProperty('number_of_iterations')
    replica_mixing_scheme = _StoredProperty('replica_mixing_scheme')
    online_analysis = _StoredProperty('online_analysis')
    online_analysis_min_iterations = _StoredProperty('online_analysis_min_iterations')
    show_energies = _StoredProperty('show_energies')
    show_mixing_statistics = _StoredProperty('show_mixing_statistics')

    # -------------------------------------------------------------------------
    # Main public interface.
    # -------------------------------------------------------------------------

    def create(self, thermodynamic_states, sampler_states, storage,
               unsampled_thermodynamic_states=None, metadata=None):
        """Create new replica-exchange simulation.

        Parameters
        ----------
        thermodynamic_states : list of openmmtools.states.ThermodynamicState
            Thermodynamic states to simulate, where one replica is allocated per state.
            Each state must have a system with the same number of atoms.
        sampler_states : openmmtools.states.SamplerState or list
            One or more sets of initial sampler states. If a list of SamplerStates,
            they will be assigned to replicas in a round-robin fashion.
        storage : str
            The path to the storage file. In the future this will be able
            to take a Reporter or a Storage class as well.
        unsampled_thermodynamic_states : list of openmmtools.states.ThermodynamicState, optional
            These are ThermodynamicStates that are not propagated, but their
            reduced potential is computed at each iteration for each replica.
            These energy can be used as data for reweighting schemes (default
            is None).
        metadata : dict, optional
           Simulation metadata to be stored in the file.

        """
        # Check if netcdf file exists. This is run only on MPI node 0 and
        # broadcasted. This is to avoid the case where the other nodes
        # arrive to this line after node 0 has already created the storage
        # file, causing an error.
        file_exists = mpi.run_single_node(0, self._does_file_exist, storage, broadcast_result=True)
        if file_exists:
            raise RuntimeError("Storage file {} already exists; cowardly "
                               "refusing to overwrite.".format(storage))

        # Make sure sampler_states is an iterable of SamplerStates for later.
        if isinstance(sampler_states, mmtools.states.SamplerState):
            sampler_states = [sampler_states]

        # Make sure there are no more sampler states than thermodynamic states.
        if len(sampler_states) > len(thermodynamic_states):
            raise ValueError('Passed {} SamplerStates but only {} ThermodynamicStates'.format(
                len(sampler_states), len(thermodynamic_states)))

        # Make sure all states have same number of particles. We don't
        # currently support writing storage with different n_particles
        n_particles = thermodynamic_states[0].n_particles
        for states in [thermodynamic_states, sampler_states]:
            for state in states:
                if state.n_particles != n_particles:
                    raise ValueError('All ThermodynamicStates and SamplerStates must '
                                     'have the same number of particles')

        # Save thermodynamic states. This sets n_replicas.
        self._thermodynamic_states = copy.deepcopy(thermodynamic_states)

        # Handle default unsampled thermodynamic states.
        if unsampled_thermodynamic_states is None:
            self._unsampled_states = []
        else:
            self._unsampled_states = copy.deepcopy(unsampled_thermodynamic_states)

        # Distribute sampler states to replicas in a round-robin fashion.
        self._sampler_states = [copy.deepcopy(sampler_states[i % len(sampler_states)])
                                for i in range(self.n_replicas)]

        # Map each thermodynamic state to a replica. Replica i at each iteration is
        # in ThermodynamicState thermodynamic_states[replica_thermodynamic_states[i]]
        # and SamplerState sampler_states[i]. During mixing, we exchange the indices
        # of the ThermodynamicState, but we keep the SamplerStates (i.e. positions,
        # velocities, box_vectors) bound to the same replica.
        self._replica_thermodynamic_states = np.array([i for i in range(self.n_replicas)], np.int64)

        # Assign default system box vectors if None has been specified.
        for replica_id, thermodynamic_state_id in enumerate(self._replica_thermodynamic_states):
            sampler_state = self._sampler_states[replica_id]
            if sampler_state.box_vectors is not None:
                continue
            thermodynamic_state = self._thermodynamic_states[thermodynamic_state_id]
            sampler_state.box_vectors = thermodynamic_state.system.getDefaultPeriodicBoxVectors()

        # Ensure there is an MCMCMove for each thermodynamic state.
        if isinstance(self._mcmc_moves, mmtools.mcmc.MCMCMove):
            self._mcmc_moves = [copy.deepcopy(self._mcmc_moves) for _ in range(self.n_replicas)]
        elif len(self._mcmc_moves) != self.n_replicas:
            raise RuntimeError('The number of MCMCMoves ({}) and ThermodynamicStates ({}) must '
                               'be the same.'.format(len(self._mcmc_moves), self.n_replicas))

        # Reset iteration counter.
        self._iteration = 0

        # Reset statistics.
        # _n_accepted_matrix[i][j] is the number of swaps proposed between thermodynamic states i and j.
        # _n_proposed_matrix[i][j] is the number of swaps proposed between thermodynamic states i and j.
        self._n_accepted_matrix = np.zeros([self.n_replicas, self.n_replicas], np.int64)
        self._n_proposed_matrix = np.zeros([self.n_replicas, self.n_replicas], np.int64)

        # Allocate memory for energy matrix. energy_thermodynamic/unsampled_states[k][l]
        # is the reduced potential computed at the positions of SamplerState sampler_states[k]
        # and ThermodynamicState thermodynamic/unsampled_states[l].
        self._energy_thermodynamic_states = np.zeros([self.n_replicas, self.n_replicas], np.float64)
        self._energy_unsampled_states = np.zeros([self.n_replicas, len(self._unsampled_states)], np.float64)

        # Display papers to be cited.
        self._display_citations()

        # Initialize reporter file.
        self._reporter = Reporter(storage, open_mode=None)  # This is open only in node 0.
        self._initialize_reporter(metadata)

    @mmtools.utils.with_timer('Minimizing all replicas')
    def minimize(self, minimize_tolerance=1.0*unit.kilojoules_per_mole/unit.nanometers,
                 minimize_max_iterations=0):
        """Minimize all replicas.

        Minimized positions are stored at the end.

        Parameters
        ----------
        minimize_tolerance : simtk.unit.Quantity, optional
            Minimization tolerance (units of energy/mole/length, default is
            1.0 * unit.kilojoules_per_mole / unit.nanometers).
        minimize_max_iterations : int, optional
            Maximum number of iterations for minimization. If 0, minimization
            continues until converged.

        """
        # Check that simulation has been created.
        if self.n_replicas == 0:
            raise RuntimeError('Cannot minimize replicas. The simulation must be created first.')

        logger.debug("Minimizing all replicas...")

        # Distribute minimization across nodes. Only node 0 will get all positions.
        # The other nodes, only need the positions that they use for propagation and
        # computation of the energy matrix entries.
        minimized_positions, sampler_state_ids = mpi.distribute(self._minimize_replica, range(self.n_replicas),
                                                                minimize_tolerance, minimize_max_iterations,
                                                                send_results_to=0)

        # Update all sampler states. For non-0 nodes, this will update only the
        # sampler states associated to the replicas propagated by this node.
        for sampler_state_id, minimized_pos in zip(sampler_state_ids, minimized_positions):
            self._sampler_states[sampler_state_id].positions = minimized_pos

        # Save the stored positions in the storage
        mpi.run_single_node(0, self._reporter.write_sampler_states, self._sampler_states, self._iteration)

    def equilibrate(self, n_iterations, mcmc_moves=None):
        """Equilibrate all replicas.

        This does not increase the iteration counter. The equilibrated
        positions are stored at the end.

        Parameters
        ----------
        n_iterations : int
            Number of equilibration iterations.
        mcmc_moves : MCMCMove or list of MCMCMove, optional
            Optionally, the MCMCMoves to use for equilibration can be
            different from the ones used in production.

        """
        # Check that simulation has been created.
        if self.n_replicas == 0:
            raise RuntimeError('Cannot minimize replicas. The simulation must be created first.')

        # If no MCMCMove is specified, use the ones for production.
        if mcmc_moves is None:
            mcmc_moves = self._mcmc_moves

        # Make sure there is one MCMCMove per thermodynamic state.
        if isinstance(mcmc_moves, mmtools.mcmc.MCMCMove):
            mcmc_moves = [copy.deepcopy(mcmc_moves) for _ in range(self.n_replicas)]
        elif len(mcmc_moves) != self.n_replicas:
            raise RuntimeError('The number of MCMCMoves ({}) and ThermodynamicStates ({}) for equilibration'
                               ' must be the same.'.format(len(self._mcmc_moves), self.n_replicas))

        # Temporarily set the equilibration MCMCMoves.
        production_mcmc_moves = self._mcmc_moves
        self._mcmc_moves = mcmc_moves
        for iteration in range(n_iterations):
            logger.debug("Equilibration iteration {}/{}".format(iteration, n_iterations))
            self._propagate_replicas()

        # Restore production MCMCMoves.
        self._mcmc_moves = production_mcmc_moves

        # Update stored positions.
        mpi.run_single_node(0, self._reporter.write_sampler_states, self._sampler_states, self._iteration)

    def run(self, n_iterations=None):
        """Run the replica-exchange simulation.

        This runs at most `number_of_iterations` iterations. Use `extend()`
        to pass the limit.

        Parameters
        ----------
        n_iterations : int, optional
           If specified, only at most the specified number of iterations
           will be run (default is None).

        """
        # If this is the first iteration, compute and store the
        # starting energies of the minimized/equilibrated structures.
        if self._iteration == 0:
            self._compute_energies()
            mpi.run_single_node(0, self._reporter.write_energies, self._energy_thermodynamic_states,
                                self._energy_unsampled_states, self._iteration)
            self._check_nan_energy()

        timer = mmtools.utils.Timer()
        timer.start('Run ReplicaExchange')
        run_initial_iteration = self._iteration

        # Handle default argument and determine number of iterations to run.
        if n_iterations is None:
            iteration_limit = self._number_of_iterations - self._iteration
        else:
            iteration_limit = min(self._iteration + n_iterations, self._number_of_iterations)

        while self._iteration < iteration_limit:
            # Increment iteration counter.
            self._iteration += 1

            logger.debug('Iteration {}/{}'.format(self._iteration, iteration_limit))
            timer.start('Iteration')

            # Attempt replica swaps to sample from equilibrium permuation of
            # states associated with replicas. This step synchronizes replicas.
            self._replica_thermodynamic_states = self._mix_replicas()

            # Propagate replicas.
            self._propagate_replicas()

            # Compute energies of all replicas at all states.
            self._compute_energies()

            # Write iteration to storage file.
            self._report_iteration()

            # Show energies.
            self._log_energies()

            # Show mixing statistics.
            self._log_mixing_statistics()

            # Perform online analysis.
            if self._online_analysis:
                self._analysis()

            # Show timing statistics if debug level is activated.
            if logger.isEnabledFor(logging.DEBUG):
                iteration_time = timer.stop('Iteration')
                partial_total_time = timer.partial('Run ReplicaExchange')
                time_per_iteration = partial_total_time / (self._iteration - run_initial_iteration)
                estimated_time_remaining = time_per_iteration * (iteration_limit - self._iteration)
                estimated_total_time = time_per_iteration * iteration_limit
                estimated_finish_time = partial_total_time + estimated_time_remaining
                logger.debug("Iteration took {:.3f}s.".format(iteration_time))
                logger.debug("Estimated completion in {}, at {} (consuming total wall clock time {}).".format(
                    str(datetime.timedelta(seconds=estimated_time_remaining)), time.ctime(estimated_finish_time),
                    str(datetime.timedelta(seconds=estimated_total_time))))

            # Perform sanity checks to see if we should terminate here.
            self._check_nan_energy()

    def extend(self, n_iterations):
        """Extend the simulation by the given number of iterations.

        Contrarily to `run()`, this will extend the number of iterations past
        `number_of_iteration` if requested.

        """
        if self._iteration + n_iterations > self._number_of_iterations:
            self.number_of_iterations = self._iteration + n_iterations
        self.run(n_iterations)

    def __repr__(self):
        """Return a 'formal' representation that can be used to reconstruct the class, if possible."""
        # TODO: Can we make this a more useful expression?
        return "<instance of ReplicaExchange>"

    def __str__(self):
        """
        Show an 'informal' human-readable representation of the replica-exchange simulation.

        """
        r = "Replica-exchange simulation\n"
        r += "\n"
        r += "{:d} replicas\n".format(self.nreplicas)
        r += "{:d} coordinate sets provided\n".format(len(self.provided_positions))
        r += "file store: {:s}\n".format(self.store_filename)
        r += "initialized: {:s}\n".format(self._initialized)
        r += "\n"
        r += "PARAMETERS\n"
        r += "collision rate: {:s}\n".format(self.collision_rate)
        r += "relative constraint tolerance: {:s}\n".format(self.constraint_tolerance)
        r += "timestep: {:s}\n".format(self.timestep)
        r += "number of steps/iteration: {:d}\n".format(self.nsteps_per_iteration)
        r += "number of iterations: {:d}\n".format(self.number_of_iterations)
        if self.extend_simulation:
            r += "Iterations extending existing data.\n"
        r += "equilibration timestep: {:s}\n".format(self.equilibration_timestep)
        r += "number of equilibration iterations: {:d}\n".format(self.number_of_equilibration_iterations)
        r += "\n"

        return r

    def __del__(self):
        mpi.run_single_node(0, self._reporter.close)

    # -------------------------------------------------------------------------
    # Internal-usage.
    # -------------------------------------------------------------------------

    def _check_nan_energy(self):
        """Checks that energies are finite and abort otherwise.

        Checks both sampled and unsampled thermodynamic states.

        """
        # Check thermodynamic state energies.
        if np.any(np.isnan(self._energy_thermodynamic_states)) or np.any(np.isnan(self._energy_unsampled_states)):
            # Find faulty replicas to create error message.
            faulty_replicas = set()

            # Check sampled thermodynamic states first.
            state_type = 'thermodynamic state'
            for replica_id in range(self.n_replicas):
                if np.any(np.isnan(self._energy_thermodynamic_states[replica_id])):
                    faulty_replicas.add(replica_id)

            # If there are no NaNs in energies, the problem is in the unsampled states.
            if len(faulty_replicas) == 0:
                state_type = 'unsampled thermodynamic state'
                for replica_id in range(self.n_replicas):
                    if np.any(np.isnan(self._unsampled_states[replica_id])):
                        faulty_replicas.add(replica_id)

            # Raise exception.
            err_msg = "NaN encountered in {} energies for replicas {}".format(state_type, faulty_replicas)
            logger.error(err_msg)
            raise RuntimeError(err_msg)

    # -------------------------------------------------------------------------
    # Internal-usage: Initialization and storage utilities.
    # -------------------------------------------------------------------------

    @staticmethod
    def _does_file_exist(file_path):
        """Check if there is a file at the given path."""
        return os.path.exists(file_path) and os.path.getsize(file_path) > 0

    @mpi.on_single_node(rank=0, broadcast_result=False, sync_nodes=True)
    def _initialize_reporter(self, metadata):
        """Initialize the reporter and store initial information.

        This is executed only on MPI node 0 and it is blocking. This is to
        avoid the case where the other nodes skip ahead and try to read
        from a file that hasn't been created yet.

        """
        self._reporter.open(mode='w')
        self._reporter.write_thermodynamic_states(self._thermodynamic_states,
                                                  self._unsampled_states)

        # Store run metadata and ReplicaExchange options.
        self._store_options()
        self._store_metadata(metadata)

        # Store initial conditions. This forces the storage to be synchronized.
        self._report_iteration()

    @mpi.on_single_node(rank=0, broadcast_result=False, sync_nodes=False)
    @mpi.delayed_termination
    @mmtools.utils.with_timer('Writing iteration information to storage')
    def _report_iteration(self):
        """Store positions, states, and energies of current iteration.

        This is executed only on MPI node 0 and it's not blocking. The
        termination is delayed so that the file is not written only with
        partial data if the program gets interrupted.

        """
        self._reporter.write_sampler_states(self._sampler_states, self._iteration)
        self._reporter.write_replica_thermodynamic_states(self._replica_thermodynamic_states, self._iteration)
        self._reporter.write_mcmc_moves(self._mcmc_moves)  # MCMCMoves can store internal statistics.
        self._reporter.write_energies(self._energy_thermodynamic_states, self._energy_unsampled_states,
                                      self._iteration)
        self._reporter.write_mixing_statistics(self._n_accepted_matrix, self._n_proposed_matrix, self._iteration)
        self._reporter.write_timestamp(self._iteration)
        self._reporter.sync()

    def _store_options(self):
        """Store __init__ parameters (beside MCMCMoves) in storage file."""
        logger.debug("Storing general ReplicaExchange options...")

        # Inspect __init__ parameters to store.
        parameter_names, _, _, defaults = inspect.getargspec(self.__init__)

        # Retrieve and store options.
        options_to_store = {parameter_name: getattr(self, '_' + parameter_name)
                            for parameter_name in parameter_names[-len(defaults):]}
        # We store the MCMCMoves separately.
        options_to_store.pop('mcmc_moves')
        self._reporter.write_dict('options', options_to_store)

    def _store_metadata(self, metadata):
        """Store metadata.

        Adds a default title if not specified.

        """
        # Handle default behavior and add default simulation title.
        default_title = ('Replica-exchange simulation created using ReplicaExchange class '
                         'of yank.repex.py on {}'.format(time.asctime(time.localtime())))
        if metadata is None:
            metadata = dict(title=default_title)
        elif 'title' not in metadata:
            metadata['title'] = default_title
        self._reporter.write_dict('metadata', metadata)

    # -------------------------------------------------------------------------
    # Internal-usage: Distributed tasks.
    # -------------------------------------------------------------------------

    @mmtools.utils.with_timer('Propagating all replicas')
    def _propagate_replicas(self):
        """Propagate all replicas."""
        # TODO  Report on efficiency of dyanmics (fraction of time wasted to overhead).
        logger.debug("Propagating all replicas...")

        # Distribute propagation across nodes. Only node 0 will get all positions
        # and box vectors. The other nodes, only need the positions that they use
        # for propagation and computation of the energy matrix entries.
        propagated_states, replica_ids = mpi.distribute(self._propagate_replica, range(self.n_replicas),
                                                        send_results_to=0)

        # Update all sampler states. For non-0 nodes, this will update only the
        # sampler states associated to the replicas propagated by this node.
        for replica_id, propagated_state in zip(replica_ids, propagated_states):
            propagated_positions, propagated_box_vectors = propagated_state  # Unpack.
            self._sampler_states[replica_id].positions = propagated_positions
            self._sampler_states[replica_id].box_vectors = propagated_box_vectors

        # Gather all MCMCMoves statistics. All nodes must have these up-to-date
        # since they are tied to the ThermodynamicState, not the replica.
        all_statistics = mpi.distribute(self._get_replica_move_statistics, range(self.n_replicas),
                                        send_results_to='all')
        for replica_id in range(self.n_replicas):
            if len(all_statistics[replica_id]) > 0:
                thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
                self._mcmc_moves[thermodynamic_state_id].statistics = all_statistics[replica_id]

    def _propagate_replica(self, replica_id):
        """Propagate thermodynamic state associated to the given replica."""
        # Retrieve thermodynamic, sampler states, and MCMC move of this replica.
        thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
        thermodynamic_state = self._thermodynamic_states[thermodynamic_state_id]
        mcmc_move = self._mcmc_moves[thermodynamic_state_id]
        sampler_state = self._sampler_states[replica_id]

        # Apply MCMC move.
        try:
            mcmc_move.apply(thermodynamic_state, sampler_state)
        except mmtools.mcmc.IntegratorMoveError as e:
            # Save NaNnig context and MCMove before aborting.
            prefix = 'nan-error-logs/iteration{}-replica{}-state{}'.format(
                self._iteration, replica_id, thermodynamic_state_id)
            e.serialize_error(prefix)
            raise

        # Return new positions and box vectors.
        return sampler_state.positions, sampler_state.box_vectors

    def _get_replica_move_statistics(self, replica_id):
        """Return the statistics of the MCMCMove currently associated to this replica."""
        thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
        mcmc_move = self._mcmc_moves[thermodynamic_state_id]

        try:
            move_statistics = mcmc_move.statistics
        except AttributeError:
            move_statistics = {}

        return move_statistics

    def _minimize_replica(self, replica_id, minimize_tolerance, minimize_max_iterations):
        """Minimize the specified replica."""
        # Retrieve thermodynamic and sampler states.
        thermodynamic_state_id = self._replica_thermodynamic_states[replica_id]
        thermodynamic_state = self._thermodynamic_states[thermodynamic_state_id]
        sampler_state = self._sampler_states[replica_id]

        # Retrieve a context. Any Integrator works.
        context, integrator = mmtools.cache.global_context_cache.get_context(thermodynamic_state)

        # Set initial positions and box vectors.
        sampler_state.apply_to_context(context)

        # Compute the initial energy of the system for logging.
        initial_energy = thermodynamic_state.reduced_potential(context)
        logger.debug('Replica {}/{}: initial energy {:8.3f}kT'.format(
            replica_id, self.n_replicas, initial_energy))

        # Minimize energy.
        openmm.LocalEnergyMinimizer.minimize(context, minimize_tolerance, minimize_max_iterations)

        # Get the minimized positions.
        sampler_state.update_from_context(context)

        # Compute the final energy of the system for logging.
        final_energy = thermodynamic_state.reduced_potential(sampler_state)
        logger.debug('Replica {}/{}: final energy {:8.3f}kT'.format(
            replica_id, self.n_replicas, final_energy))

        # Return minimized positions.
        return sampler_state.positions

    @mmtools.utils.with_timer('Computing energy matrix')
    def _compute_energies(self):
        """Compute energies of all replicas at all states."""

        # Distribute energy computation across nodes. Only node 0 receives
        # all the energies since it needs to store them and mix states.
        new_energies, replica_ids = mpi.distribute(self._compute_replica_energies, range(self.n_replicas),
                                                   send_results_to=0)

        # Update energy matrices. Non-0 nodes update only the energies computed by this replica.
        for replica_id, energies in zip(replica_ids, new_energies):
            energy_thermodynamic_states, energy_unsampled_states = energies  # Unpack.
            self._energy_thermodynamic_states[replica_id] = energy_thermodynamic_states
            self._energy_unsampled_states[replica_id] = energy_unsampled_states

    def _compute_replica_energies(self, replica_id):
        """Compute the energy for the replica in every ThermodynamicState."""
        # Initialize replica energies for each thermodynamic state.
        energy_thermodynamic_states = np.zeros(self.n_replicas)
        energy_unsampled_states = np.zeros(len(self._unsampled_states))

        # Retrieve sampler state associated to this replica.
        sampler_state = self._sampler_states[replica_id]

        # Compute energy for all thermodynamic states.
        for energies, states in [(energy_thermodynamic_states, self._thermodynamic_states),
                                 (energy_unsampled_states, self._unsampled_states)]:
            for i, state in enumerate(states):
                # Get the context, any Integrator works.
                context, integrator = mmtools.cache.global_context_cache.get_context(state)

                # Update positions and box vectors. We don't need
                # to set Context velocities for the potential.
                sampler_state.apply_to_context(context, ignore_velocities=True)

                # Compute energy.
                energies[i] = state.reduced_potential(context)

        # Return the new energies.
        return energy_thermodynamic_states, energy_unsampled_states

    # -------------------------------------------------------------------------
    # Internal-usage: Replicas mixing.
    # -------------------------------------------------------------------------

    _SUPPORTED_MIXING_SCHEMES = frozenset(['swap-all', 'swap-neighbors', 'none'])

    @mpi.on_single_node(0, broadcast_result=True)
    def _mix_replicas(self):
        """Attempt to swap replicas according to user-specified scheme."""
        logger.debug("Mixing replicas...")

        # Reset storage to keep track of swap attempts this iteration.
        self._n_accepted_matrix[:, :] = 0
        self._n_proposed_matrix[:, :] = 0

        # Perform swap attempts according to requested scheme.
        assert self._replica_mixing_scheme in self._SUPPORTED_MIXING_SCHEMES
        with mmtools.utils.time_it('Mixing of replicas'):
            if self._replica_mixing_scheme == 'swap-neighbors':
                self._mix_neighboring_replicas()
            elif self._replica_mixing_scheme == 'swap-all':
                # Try to use cython-accelerated mixing code if possible,
                # otherwise fall back to Python-accelerated code.
                try:
                    self._mix_all_replicas_cython()
                except ValueError as e:
                    logger.warning(e.message)
                    self._mix_all_replicas()
            else:
                assert self._replica_mixing_scheme == 'none'

        # Determine fraction of swaps accepted this iteration.
        n_swaps_proposed = self._n_proposed_matrix.sum()
        n_swaps_accepted = self._n_accepted_matrix.sum()
        swap_fraction_accepted = 0.0
        if n_swaps_proposed > 0:
            # TODO drop casting to float when dropping Python 2 support.
            swap_fraction_accepted = float(n_swaps_accepted) / n_swaps_proposed
        logger.debug("Accepted {}/{} attempted swaps ({:.1f}%)".format(n_swaps_accepted, n_swaps_proposed,
                                                                       swap_fraction_accepted * 100.0))

        # Return new states indices for MPI broadcasting.
        return self._replica_thermodynamic_states

    def _mix_all_replicas_cython(self):
        """Exchange all replicas with Cython-accelerated code."""
        from .mixing._mix_replicas import _mix_replicas_cython

        replica_states = md.utils.ensure_type(self._replica_thermodynamic_states, np.int64, 1, "Replica States")
        u_kl = md.utils.ensure_type(self._energy_thermodynamic_states, np.float64, 2, "Reduced Potentials")
        n_proposed_matrix = md.utils.ensure_type(self._n_proposed_matrix, np.int64, 2, "Nij Proposed Swaps")
        n_accepted_matrix = md.utils.ensure_type(self._n_accepted_matrix, np.int64, 2, "Nij Accepted Swaps")
        _mix_replicas_cython(self.n_replicas**4, self.n_replicas, replica_states,
                             u_kl, n_proposed_matrix, n_accepted_matrix)

        self._replica_thermodynamic_states = replica_states
        self._n_proposed_matrix = n_proposed_matrix
        self._n_accepted_matrix = n_accepted_matrix

    def _mix_all_replicas(self):
        """Exchange all replicas with Python."""
        # Determine number of swaps to attempt to ensure thorough mixing.
        # TODO: Replace this with analytical result computed to guarantee sufficient mixing, or
        # TODO:     adjust it  based on how many we can afford to do and not have mixing take a
        # TODO:     substantial fraction of iteration time.
        nswap_attempts = self.n_replicas**5  # Number of swaps to attempt (ideal, but too slow!)
        nswap_attempts = self.n_replicas**3  # Best compromise for pure Python?

        logger.debug("Will attempt to swap all pairs of replicas, using a total of %d attempts." % nswap_attempts)

        # Attempt swaps to mix replicas.
        for swap_attempt in range(nswap_attempts):
            # Choose random replicas uniformly to attempt to swap.
            replica_i = np.random.randint(self.n_replicas)
            replica_j = np.random.randint(self.n_replicas)
            self._attempt_swap(replica_i, replica_j)

    def _mix_neighboring_replicas(self):
        """Attempt exchanges between neighboring replicas only."""
        logger.debug("Will attempt to swap only neighboring replicas.")

        # Attempt swaps of pairs of replicas using traditional scheme (e.g. [0,1], [2,3], ...).
        offset = np.random.randint(2)  # Offset is 0 or 1.
        for thermodynamic_state_i in range(offset, self.n_replicas-1, 2):
            thermodynamic_state_j = thermodynamic_state_i + 1  # Neighboring state.

            # Determine which replicas currently hold the thermodynamic states.
            replica_i = np.where(self._replica_thermodynamic_states == thermodynamic_state_i)
            replica_j = np.where(self._replica_thermodynamic_states == thermodynamic_state_j)
            self._attempt_swap(replica_i, replica_j)

    def _attempt_swap(self, replica_i, replica_j):
        """Attempt a single exchange between two replicas."""
        # Determine the thermodynamic states associated to these replicas.
        thermodynamic_state_i = self._replica_thermodynamic_states[replica_i]
        thermodynamic_state_j = self._replica_thermodynamic_states[replica_j]

        # Compute log probability of swap.
        energy_ij = self._energy_thermodynamic_states[replica_i, thermodynamic_state_j]
        energy_ji = self._energy_thermodynamic_states[replica_j, thermodynamic_state_i]
        energy_ii = self._energy_thermodynamic_states[replica_i, thermodynamic_state_i]
        energy_jj = self._energy_thermodynamic_states[replica_j, thermodynamic_state_j]
        log_p_accept = - (energy_ij + energy_ji) + energy_ii + energy_jj

        # Record that this move has been proposed.
        self._n_proposed_matrix[thermodynamic_state_i, thermodynamic_state_j] += 1
        self._n_proposed_matrix[thermodynamic_state_j, thermodynamic_state_i] += 1

        # Accept or reject.
        if log_p_accept >= 0.0 or np.random.rand() < math.exp(log_p_accept):
            # Swap states in replica slots i and j.
            self._replica_thermodynamic_states[replica_i] = thermodynamic_state_j
            self._replica_thermodynamic_states[replica_j] = thermodynamic_state_i
            # Accumulate statistics.
            self._n_accepted_matrix[thermodynamic_state_i, thermodynamic_state_j] += 1
            self._n_accepted_matrix[thermodynamic_state_j, thermodynamic_state_i] += 1

    # -------------------------------------------------------------------------
    # Internal-usage: Analysis.
    # -------------------------------------------------------------------------

    # TODO use code in analyze to avoid duplication.
    # TODO make show_statistics/energy Yank/Logger/Analyzer options instead?
    # TODO make online_analysis Yank/Analyzer option instead?

    def _accumulate_mixing_statistics(self):
        """Return the mixing transition matrix."""
        try:
            return self._accumulate_mixing_statistics_update()
        except AttributeError:
            pass
        except ValueError:
            logger.info("Inconsistent transition count matrix detected, recalculating from scratch.")

        return self._accumulate_mixing_statistics_full()

    def _accumulate_mixing_statistics_full(self):
        """Compute statistics of transitions iterating over all iterations of repex."""
        states = self._reporter.read_replica_thermodynamic_states(iteration=slice(None))

        # Create a cumulative transition counts matrix and cache last
        # replica_thermodynamic_states indices to avoid access to storage.
        self._cached_transition_counts = np.zeros([self.n_replicas, self.n_replicas], np.float64)
        self._cached_last_replica_thermodynamic_states = self._replica_thermodynamic_states.copy()

        # Accumulate transition counts.
        for iteration in range(states.shape[0] - 1):
            for replica_id in range(self.n_replicas):
                thermodynamic_state_i = states[iteration, replica_id]
                thermodynamic_state_j = states[iteration + 1, replica_id]
                self._cached_transition_counts[thermodynamic_state_i, thermodynamic_state_j] += 0.5
                self._cached_transition_counts[thermodynamic_state_j, thermodynamic_state_i] += 0.5

        # Normalize to obtain transition matrix. state_n_total_transitions is always
        # at least one because iteration 0 is just for minimization/equilibration.
        transition_matrix = np.zeros([self.n_replicas, self.n_replicas], np.float64)
        for state_id in range(self.n_replicas):
            state_n_total_transitions = self._cached_transition_counts[state_id].sum()
            transition_matrix[state_id] = self._cached_transition_counts[state_id] / state_n_total_transitions

        return transition_matrix

    def _accumulate_mixing_statistics_update(self):
        """Compute statistics of transitions updating Nij of last iteration of repex."""
        # Check that we have exactly one new iteration to process.
        if self._cached_last_iteration_mixing.sum() != (self._iteration - 2) * self.n_replicas:
            raise RuntimeError("Inconsistent transition count matrix detected. "
                               "Perhaps you tried updating twice in a row?")

        # Add counts for last iteration.
        for replica_id in range(self.n_replicas):
            thermodynamic_state_i = self._cached_last_replica_thermodynamic_states[replica_id]
            thermodynamic_state_j = self._replica_thermodynamic_states[replica_id]
            self._cached_transition_counts[thermodynamic_state_i, thermodynamic_state_j] += 0.5
            self._cached_transition_counts[thermodynamic_state_j, thermodynamic_state_i] += 0.5

        # Normalizing to obtain transition matrix.
        transition_matrix = np.zeros([self.n_replicas, self.n_replicas], np.float64)
        for state_id in range(self.n_replicas):
            state_n_total_transitions = self._cached_transition_counts[state_id].sum()
            transition_matrix[state_id] = self._cached_transition_counts[state_id] / state_n_total_transitions

        # Updated cached information for next iteration.
        self._cached_last_replica_thermodynamic_states = self._replica_thermodynamic_states.copy()

        return transition_matrix

    @mpi.on_single_node(0, broadcast_result=True)
    def _analysis(self):
        """Perform online analysis.

        Every iteration, this will update the estimate of the state relative
        free energy differences and statistical uncertainties. We can additionally
        request further analysis.

        """
        # Determine how many iterations there are data available for.
        replica_states = self._reporter.read_replica_thermodynamic_states(iteration=slice(None))
        u_nkl_replica, u_unsampled = self._reporter.read_energies(iteration=slice(None))

        # Determine number of iterations completed.
        number_of_iterations_completed = replica_states.shape[0]
        nstates = replica_states.shape[1]

        # Online analysis can only be performed after a sufficient quantity of data has been collected.
        if number_of_iterations_completed < self.online_analysis_min_iterations:
            logger.debug(("Online analysis will be performed after {} iterations "
                          "have elapsed.").format(self._online_analysis_min_iterations))

        # Deconvolute replicas and compute total simulation effective self-energy timeseries.
        u_kln = np.zeros([nstates, nstates, number_of_iterations_completed], np.float32)
        u_n = np.zeros([number_of_iterations_completed], np.float64)
        for iteration in range(number_of_iterations_completed):
            state_indices = replica_states[iteration,:]
            u_n[iteration] = 0.0
            for replica_index in range(nstates):
                state_index = state_indices[replica_index]
                u_n[iteration] += u_nkl_replica[iteration, replica_index, state_index]
                u_kln[state_index, :, iteration] = u_nkl_replica[iteration, replica_index, :]

        # Determine optimal equilibration time, statistical inefficiency, and effectively uncorrelated sample indices.
        from pymbar import timeseries
        [t0, g, Neff_max] = timeseries.detectEquilibration(u_n)
        indices = t0 + timeseries.subsampleCorrelatedData(u_n[t0:], g=g)
        N_k = indices.size * np.ones([nstates], np.int32)

        # Next, analyze with pymbar, initializing with last estimate of free energies.
        from pymbar import MBAR
        if hasattr(self, 'f_k'):
            mbar = MBAR(u_kln[:, :, indices], N_k, initial_f_k=self.f_k)
        else:
            mbar = MBAR(u_kln[:, :, indices], N_k)

        # Cache current free energy estimate to save time in future MBAR solutions.
        self.f_k = mbar.f_k

        # Compute entropy and enthalpy.
        [Delta_f_ij, dDelta_f_ij, Delta_u_ij, dDelta_u_ij, Delta_s_ij, dDelta_s_ij] = mbar.computeEntropyAndEnthalpy()

        # Store analysis summary.
        # TODO: Convert this to an object?
        analysis = dict()
        analysis['equilibration_end'] = t0
        analysis['g'] = g
        analysis['indices'] = indices
        analysis['Delta_f_ij'] = Delta_f_ij
        analysis['dDelta_f_ij'] = dDelta_f_ij
        analysis['Delta_u_ij'] = Delta_u_ij
        analysis['dDelta_u_ij'] = dDelta_u_ij
        analysis['Delta_s_ij'] = Delta_s_ij
        analysis['dDelta_s_ij'] = dDelta_s_ij

        def matrix2str(x):
            """
            Return a print-ready string version of a matrix of numbers.

            Parameters
            ----------
            x : numpy.array of nrows x ncols matrix
               Matrix of numbers to print.

            """
            # TODO Automatically determine optimal spacing
            [nrows, ncols] = x.shape
            str_row = ""
            for i in range(nrows):
                for j in range(ncols):
                    str_row += "%8.3f" % x[i, j]
                str_row += "\n"
            return str_row

        # Print estimate
        if logger.isEnabledFor(logging.DEBUG):
            logger.debug("================================================================================")
            logger.debug("Online analysis estimate of free energies:")
            logger.debug("  equilibration end: %d iterations" % t0)
            logger.debug("  statistical inefficiency: %.1f iterations" % g)
            logger.debug("  effective number of uncorrelated samples: %.1f" % Neff_max)
            logger.debug("Reduced free energy (f), enthalpy (u), and entropy (s) differences among thermodynamic states:")
            logger.debug("Delta_f_ij")
            logger.debug(matrix2str(Delta_f_ij))
            logger.debug("dDelta_f_ij")
            logger.debug(matrix2str(dDelta_f_ij))
            logger.debug("Delta_u_ij")
            logger.debug(matrix2str(Delta_u_ij))
            logger.debug("dDelta_u_ij")
            logger.debug(matrix2str(dDelta_u_ij))
            logger.debug("Delta_s_ij")
            logger.debug(matrix2str(Delta_s_ij))
            logger.debug("dDelta_s_ij")
            logger.debug(matrix2str(dDelta_s_ij))
            logger.debug("================================================================================")

        return analysis

    def analyze(self):
        """
        Analyze the current simulation and return estimated free energies.

        Returns
        -------
        analysis : dict
           Analysis object containing end of equilibrated region, statistical
           inefficiency, and free energy differences.

        Keys
        ----
        equilibration_end : int
           The last iteration in the discarded equilibrated region.
        g : float
           Estimated statistical inefficiency of production region.
        indices : list of int
           Equilibrated, effectively uncorrelated iteration indices used in analysis.
        Delta_f_ij : numpy array of nstates x nstates
           Delta_f_ij[i,j] is the free energy difference f_j - f_i in units of kT.
        dDelta_f_ij : numpy array of nstates x nstates
           dDelta_f_ij[i,j] is estimated standard error of Delta_f_ij[i,j].
        Delta_u_ij
           Delta_u_ij[i,j] is the reduced enthalpy difference u_j - u_i in units of kT.
        dDelta_u_ij
           dDelta_u_ij[i,j] is estimated standard error of Delta_u_ij[i,j].
        Delta_s_ij
           Delta_s_ij[i,j] is the reduced entropic contribution to the free energy.
           difference s_j - s_i in units of kT
        dDelta_s_ij
           dDelta_s_ij[i,j] is estimated standard error of Delta_s_ij[i,j].

        """
        # Update analysis on root node.
        self.analysis = self._analysis()

        # Return analysis object
        return self.analysis

    # -------------------------------------------------------------------------
    # Internal-usage: Logging.
    # -------------------------------------------------------------------------

    @mpi.on_single_node(0, sync_nodes=False)
    def _log_mixing_statistics(self):
        """Log mixing statistics."""
        if self._iteration < 2 or not self._show_mixing_statistics:
            return
        print_cutoff = 0.001  # Cutoff for displaying fraction of accepted swaps.

        transition_matrix = self._accumulate_mixing_statistics()

        # Print observed transition probabilities.
        logger.debug("Cumulative symmetrized state mixing transition matrix:")
        str_row = "%6s" % ""
        for thermodynamic_state_j in range(self.n_replicas):
            str_row += "%6d" % thermodynamic_state_j
        logger.debug(str_row)
        for thermodynamic_state_i in range(self.n_replicas):
            str_row = "%-6d" % thermodynamic_state_i
            for thermodynamic_state_j in range(self.n_replicas):
                p = transition_matrix[thermodynamic_state_i, thermodynamic_state_j]
                if p >= print_cutoff:
                    str_row += "%6.3f" % p
                else:
                    str_row += "%6s" % ""
            logger.debug(str_row)

        # Estimate second eigenvalue and equilibration time.
        mu = np.linalg.eigvals(transition_matrix)
        mu = -np.sort(-mu)  # Sort in descending order.
        if mu[1] >= 1:
            logger.debug("Perron eigenvalue is unity; Markov chain is decomposable.")
        else:
            logger.debug("Perron eigenvalue is {:9.5f}; state equilibration timescale "
                         "is ~ {:.1f} iterations".format(mu[1], 1.0 / (1.0 - mu[1])))

    @mpi.on_single_node(0, sync_nodes=False)
    def _log_energies(self):
        """Log energies (in units of kT) for all replicas at all states."""
        if not logger.isEnabledFor(logging.DEBUG) or not self._show_energies:
            return

        # print header
        str_row = "%-24s %16s" % ("reduced potential (kT)", "current state")
        for state_index in range(self.n_replicas):
            str_row += " state %3d" % state_index
        logger.debug(str_row)

        # print energies in kT
        for replica_index in range(self.n_replicas):
            str_row = "replica %-16d %16d" % (replica_index, self._replica_thermodynamic_states[replica_index])
            for state_index in range(self.n_replicas):
                u = self._energy_thermodynamic_states[replica_index, state_index]
                if u > 1e6:
                    str_row += "%10.3e" % u
                else:
                    str_row += "%10.1f" % u
            logger.debug(str_row)

    def _display_citations(self):
        """Display papers to be cited."""
        # TODO Add original citations for various replica-exchange schemes.
        # TODO Show subset of OpenMM citations based on what features are being used.
        openmm_citations = """\
        Friedrichs MS, Eastman P, Vaidyanathan V, Houston M, LeGrand S, Beberg AL, Ensign DL, Bruns CM, and Pande VS. Accelerating molecular dynamic simulations on graphics processing unit. J. Comput. Chem. 30:864, 2009. DOI: 10.1002/jcc.21209
        Eastman P and Pande VS. OpenMM: A hardware-independent framework for molecular simulations. Comput. Sci. Eng. 12:34, 2010. DOI: 10.1109/MCSE.2010.27
        Eastman P and Pande VS. Efficient nonbonded interactions for molecular dynamics on a graphics processing unit. J. Comput. Chem. 31:1268, 2010. DOI: 10.1002/jcc.21413
        Eastman P and Pande VS. Constant constraint matrix approximation: A robust, parallelizable constraint method for molecular simulations. J. Chem. Theor. Comput. 6:434, 2010. DOI: 10.1021/ct900463w"""

        gibbs_citations = """\
        Chodera JD and Shirts MR. Replica exchange and expanded ensemble simulations as Gibbs sampling: Simple improvements for enhanced mixing. J. Chem. Phys., 135:194110, 2011. DOI:10.1063/1.3660669"""

        mbar_citations = """\
        Shirts MR and Chodera JD. Statistically optimal analysis of samples from multiple equilibrium states. J. Chem. Phys. 129:124105, 2008. DOI: 10.1063/1.2978177"""

        print("Please cite the following:")
        print("")
        print(openmm_citations)
        if self._replica_mixing_scheme == 'swap-all':
            print(gibbs_citations)
        if self._online_analysis:
            print(mbar_citations)


# ==============================================================================
# PARALLEL TEMPERING
# ==============================================================================

class ParallelTempering(ReplicaExchange):
    """Parallel tempering simulation facility.

    This class provides a facility for parallel tempering simulations. It
    is a subclass of ReplicaExchange, but provides efficiency improvements
    for parallel tempering simulations, so should be preferred for this type
    of simulation. In particular, this makes use of the fact that the reduced
    potentials are linear in inverse temperature.

    Examples
    --------

    Create the system.

    >>> from simtk import unit
    >>> from openmmtools import testsystems, states, mcmc
    >>> testsystem = testsystems.AlanineDipeptideImplicit()

    Create thermodynamic states for parallel tempering with exponentially-spaced schedule.

    >>> n_replicas = 3  # Number of temperature replicas.
    >>> T_min = 298.0 * unit.kelvin  # Minimum temperature.
    >>> T_max = 600.0 * unit.kelvin  # Maximum temperature.
    >>> reference_state = states.ThermodynamicState(system=testsystem.system, temperature=T_min)

    Initialize simulation object with options. Run with a GHMC integrator.

    >>> move = mcmc.GHMCMove(timestep=2.0*unit.femtoseconds, n_steps=50)
    >>> simulation = ParallelTempering(mcmc_moves=move, number_of_iterations=2)

    Create simulation with its storage file (in a temporary directory) and run.

    >>> storage_path = tempfile.NamedTemporaryFile(delete=False).name + '.nc'
    >>> simulation.create(thermodynamic_states=thermodynamic_states,
    >>>                   sampler_states=states.SamplerState(testsystem.positions),
    ...                   storage=storage_path, min_temperature=T_min,
    ...                   max_temperature=T_max, n_temperatures=n_replicas)
    >>> simulation.run(n_iterations=1)

    Clean up.

    >>> os.remove(storage_path)

    """

    def create(self, thermodynamic_state, sampler_states, storage, min_temperature=None,
               max_temperature=None, n_temperatures=None, temperatures=None, metadata=None):
        """Initialize a parallel tempering simulation object.

        Parameters
        ----------
        thermodynamic_state : openmmtools.states.ThermodynamicState
            Reference thermodynamic state that will be simulated at the given
            temperatures.
        sampler_states : openmmtools.states.SamplerState or list
            One or more sets of initial sampler states. If a list of SamplerStates,
            they will be assigned to replicas in a round-robin fashion.
        storage : str
            The path to the storage file. In the future this will be able
            to take a Reporter or a Storage class as well.
        min_temperature : simtk.unit.Quantity, optional
           Minimum temperature (units of temperature, default is None).
        max_temperature : simtk.unit.Quantity, optional
           Maximum temperature (units of temperature, default is None).
        n_temperatures : int, optional
           Number of exponentially-spaced temperatures between min_temperature
           and max_temperature (default is None).
        temperatures : list of simtk.unit.Quantity, optional
           If specified, this list of temperatures will be used instead of
           min_temperature, max_temperature, and n_temperatures (units of temeprature,
           default is None).
        metadata : dict, optional
           Simulation metadata to be stored in the file.

        Notes
        -----
        Either (min_temperature, max_temperature, n_temperatures) must all be
        specified or the list of 'temperatures' must be specified.

        """
        # Create thermodynamic states from temperatures.
        if temperatures is not None:
            logger.debug("Using provided temperatures")
        elif min_temperature is not None and max_temperature is not None and n_temperatures is not None:
            # TODO drop casting to float when dropping Python 2 support.
            temperatures = [min_temperature + (max_temperature - min_temperature) *
                            (math.exp(i / float(n_temperatures-1)) - 1.0) / (math.e - 1.0)
                            for i in range(n_temperatures)]
            logger.debug('using temperatures {}'.format(temperatures))
        else:
            raise ValueError("Either 'temperatures' or 'min_temperature', 'max_temperature', "
                             "and 'n_temperatures' must be provided.")

        thermodynamic_states = [copy.deepcopy(thermodynamic_state) for _ in range(n_temperatures)]
        for state, temperature in zip(thermodynamic_states, temperatures):
            state.temperature = temperature

        # Override default title.
        default_title = ('Parallel tempering simulation created using ParallelTempering '
                         'class of yank.repex.py on {}'.format(time.asctime(time.localtime())))
        if metadata is None:
            metadata = dict(title=default_title)
        elif 'title' not in metadata:
            metadata['title'] = default_title

        # Initialize replica-exchange simlulation.
        super(ParallelTempering, self).create(self, thermodynamic_states, sampler_states,
                                              storage=storage, metadata=metadata)

    def _compute_replica_energies(self, replica_id):
        """Compute the energy for the replica at every temperature.

        Because only the temperatures differ among replicas, we replace the generic O(N^2)
        replica-exchange implementation with an O(N) implementation.

        """
        # Initialize replica energies for each thermodynamic state.
        replica_energies = np.zeros(self.n_replicas)

        # Retrieve sampler states associated to this replica.
        sampler_state = self._sampler_states[replica_id]

        # Thermodynamic state differ only by temperatures.
        reference_thermodynamic_state = self._thermodynamic_states[0]

        # Get the context, any Integrator works.
        context, integrator = mmtools.cache.global_context_cache.get_context(reference_thermodynamic_state)

        # Update positions and box vectors.
        sampler_state.apply_to_context(context)

        # Compute energy.
        reference_reduced_potential = reference_thermodynamic_state.reduced_potential(context)

        # Strip reference potential of reference state's beta.
        reference_beta = 1.0 / (mmtools.constants.kB * reference_thermodynamic_state.temperature)
        reference_reduced_potential /= reference_beta

        # Update potential energy by temperature.
        for thermodynamic_state_id, thermodynamic_state in enumerate(self._thermodynamic_states):
            beta = 1.0 / (mmtools.constants.kB * thermodynamic_state.temperature)
            replica_energies[replica_id, thermodynamic_state_id] = beta * reference_reduced_potential

        # Return the new energies.
        return replica_energies


# ==============================================================================
# MAIN AND TESTS
# ==============================================================================

if __name__ == "__main__":
    import doctest
    doctest.testmod()
