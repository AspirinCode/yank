#yank-yaml0.1
---
metadata:
  title:
  email:

# Separate options / yank block, or put all yank/repex/alchemy at base level?
options:
  yank:
    minimize: yes
    output_directory: /path/to/output/
  repex:
    timestep: 1.0 * femtoseconds
    nsteps_per_iteration: 2500
    niterations: 1000
  alchemy:
    path_discovery: yes

molecules:
  abl-2hyy:
    rcsbid: 2hyy
    select: "chain A"
    mutations: "ASP-137-ASH"
    parameters: ['amber99sbildn.xml', 'ions.xml']
    loopoptions: stuff for loop refinement

  imatinib:
    filename: gleevec.smiles
    epik: 0  # take 0th state from epik for protonation
    parameters: antechamber/paramchem
  bosutinib:
    prmtop: bosu.prmtop      or      charmmpsf: bosu.psf
    inpcrd: bosu.inpcrd      or      charmmpdb: bosu.pdb

  p38-schrodinger:
    filename: p38_protein.pdb
  p38-ligands:
    filename: p32_ligands.sdf
    select: [p38a_2n, p38a_3flz, p38a_2h]  # how do we handle multi-molecules files?

solvents:
  vacuum:
    nonbondedMethod: NoCutoff
  PMEtip3p:
    nonbondedMethod: PME
    solvate: PME
    solventmodel: tip3p
    salt:
      NaCl: 150*millimolar
      MgCl2: 10*millimolar
    clearance: 10*angstroms
  RFtip3p:
    nonbondedMethod: RF
    solventmodel: tip3p
    salt:
      NaCl: 150*millimolar
      MgCl2: 10*millimolar
    clearance: 10*angstroms
  PMEtip4p:
    nonbondedMethod: PME
    solventmodel: tip4p
    salt:
      KCl: 150*millimolar
    clearance: 10*angstroms
  GBSAobc1:
    nonbondedMethod: NoCutoff
    gbsamodel: obc1
  GBSAobc2:
    nonbondedMethod: NoCutoff
    gbsamodel: obc2

phases:
  vacuum: [ligand]
  solvent: [ligand, water]
  complex: [receptor, ligand, water]
  octanol: [ligand, octanol]

alchemy:
  alchemical_factory: AbsoluteAlchemicalFactory
  # specify components for alchemical modification
  receptor_atoms: receptor
  ligand_atoms: ligand
  # other options for alchemical transformations
  annihilate_sterics: False
  annihilate_electrostatics: True

  # Think about how we specify ligand or receptor relative changes
  #alchemical_factory: RelativeAlchemicalFactory
  #alchemical_atoms: receptor

  # or 

  #alchemical_factory: MultiLigandAlchemicalFactory

  # Define default phases for alchemical protocols?
  alchemical_protocols:
    solvent: 
      lambda_electrostatics: [1.0, 0.9, 0.8, ...]
      lambda_sterics: [1.0, 0.9, 0.8, ...]

  # or?
  # Aliases for protocols to use in experiments
  standard_protocol:
    lambda_electrostatics: [1.0, 0.9, 0.8, ...]
    lambda_sterics: [1.0, 0.9, 0.8, ...]
  20states_protocol:
    lambda_electrostatics: [1.0, 0.95, 0.9, ...]
    lambda_sterics: [1.0, 0.95, 0.9, ...]

# everything here is done serially
experiment1:
  components:
    receptor: abl-2hyy
    ligand: imatinib
  mutations:  # both receptors and eventual peptide ligands
    abl-2hyy: VAL31ALA  # these mutations are on top of molecules.abl-2hyy.mutations
  solvents: PMEtip3p
  hmr: yes
  phases:
    complex:
      alchemy: standard_protocol
      phase_options:
        repex.niterations: 1000
    solvent:
      alchemy: standard_protocol
      phase_options:
        repex.niterations: 100

# everything that is in lists is combinatorial
experiment2:
  receptor: [abl-2hyy, ...]
  ligand: [imatinib, afatinib, bosutinib]
  mutations:  # both receptors and eventual peptide ligands
    abl-2hyy: [VAL31ALA, ...]  # these mutations are on top of molecules.abl-2hyy.mutations
  solvents: [PMEtip3p, RFtip3p, PMEtip4p, GBSAobc1, GBSAobc2]
  hmr: [yes, no]
  phases:
    complex:
      alchemy: [standard_protocol, 20states_protocol]
      phase_options:
        repex.niterations: [1000, 2000]
    solvent:
      alchemy: standard_protocol
      phase_options:
        repex.niterations: 100

experiment2: [experiment1, experiment2]

